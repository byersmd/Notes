# IOT 110A/B - Internet of Things: Foundations Student Resource Repository #

## Link to Adobe Connect Online 
[Online Meeting Room](http://uweoconnect.extn.washington.edu/iot110/)

## Setting up RPi3
[RPi3 Setup](https://gitlab.com/iot110/iot110-student/blob/master/Resources/PI_SETUP.md)

## Outline
* [Lab 1](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab1/setup.md) - Flask WebApp - Hello IoT World!
* [Lab 2](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md) - LEDs and Switches (GPIO) via Python
* [Lab 3](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md) - Server Sent Events and Bootstrap UI
* [Lab 4](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/setup.md) - Sensors: I2C Pressure/Temperature via the BMP280
* [Lab 5](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/setup.md) - Sensors: Thing Data Protocols/Webapp for the BMP280
* [Lab 6](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/setup.md) - Sensors: Thing Data Protocols/Webapp for the SenseHat
* [Lab 7](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/setup.md) - Actuators: PWM LED Dimmer Controller & Stepper Motor / via the TB6612
* [Lab 8](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/setup.md) - Basic Networking (Simple Gateway Edge Devices)
* [Lab 9](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/setup.md) - Collect to Cloud using MQTT

## Webpage
[UW-PCE IoT Website](https://www.pce.uw.edu/certificates/internet-of-things)


## Lab Equipment List
| ITEM #  | DESCRIPTION |  QTY  | COST | COMPONENT | BUY URL| OTHER |
| :-----: | :---------- | :---: | ---: | :--------: | :-----------------| :-------- |
| 1  | Raspberry Pi 3 Kit | 1 | $89.95 | [RaspberryPi3](https://www.raspberrypi.org/) | [Adafruit](https://www.adafruit.com/products/3058) |  [Alternate](https://www.amazon.com/dp/B01C6Q4GLE?psc=1) |      
| 2  | Pi Sensor HAT    | 1 | $39.95 | Sensors | [Adafruit](https://www.adafruit.com/products/2738) | [Astro-Pi](https://astro-pi.org/) |
| 3  | Barometric Pressure & Temperature Sensor | 1 | $9.95 | [BMP280](https://www.bosch-sensortec.com/bst/products/all_products/bmp280) | [Adafruit](https://www.adafruit.com/products/2651) | [AppNote](https://cdn-learn.adafruit.com/downloads/pdf/adafruit-bmp280-barometric-pressure-plus-temperature-sensor-breakout.pdf) | [Datasheet](https://cdn-shop.adafruit.com/datasheets/BST-BMP280-DS001-11.pdf) |
| 4  | Stepper Motor Breakout Board | 1 | $4.95 | [TB6612](http://toshiba.semicon-storage.com/ap-en/product/linear/motordriver/detail.TB6612FNG.html) | [Adafruit](https://www.adafruit.com/products/2448) | [AppNote](https://cdn-learn.adafruit.com/downloads/pdf/adafruit-tb6612-h-bridge-dc-stepper-motor-driver-breakout.pdf) | [Datasheet](http://toshiba.semicon-storage.com/ap-en/product/linear/motordriver/detail.TB6612FNG.html) |
| 5  | NEMA 17 Stepper Motor| 1 | $14.00 | | [Adafruit ](https://www.adafruit.com/products/324) | |
| 6  | Automotive Gauge Stepper Motor | 1| $9.95| | [AutoNeedle](https://www.adafruit.com/products/2424) | |
| 7  | TFT 5 inch Monitor |	1 | $13.32 | | [Adafruit](https://www.adafruit.com/products/2232) | | |
| 8  | HDMI Flat Cable | 1 | $11.29 | | [Adafruit](https://www.adafruit.com/products/2197) | |
| 9  | Microsoft Keyboard | 1 | $59.95 | | [Amazon](http://amzn.to/2djI91K) |
| 10 | Microsoft Wired Mouse | 1 | $3.95 | | [Amazon](http://amzn.to/2esKjlm) |
| 11 | Micro USB Charge Sync GOLD Data Cable | 2 |	$9.98 |	| [Amazon](http://amzn.to/2e49OHk) |
| 12 | Anker 24W Dual USB Wall Charger PowerPort 2 | 1 | $12.49 | | [Amazon](http://amzn.to/2ejevvC) |
| 13 | STRAP BATT ECON 9V I STYLE 4"LD |	1 | $0.60 | | [Digikey](http://bit.ly/2gFinYM) |
| 14 | Alkaline Battery Non-Rechargeable 9V | 2 | $4.76 | | [Digikey](http://bit.ly/2fLQYYl) |
| 15 | HEX STANDOFF 4-40 NYLON 1/2" | 8 | $5.60 | | [Digikey](http://bit.ly/2iWFqOT) |
| 16 | MACHINE SCREW PAN PHILLIPS 4-40 | 8 | $0.80 | | [Digikey](http://bit.ly/2iqhxlT) |
| 17 | 2 Position Wire to Board Terminal Block | 1	| $0.57 | | [Digikey](http://bit.ly/2gMUtgG) |
|    | | TOTAL | $292.06 | | |
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up Lab1

### Objectives
For this lab we will be setting up a local web application running on the RPi
that will act as our primary user interface in a *headless* mode (i.e. not
requiring the HDMI graphic monitor connected to the RPi to interact with our
sensor and actuator devices.  The scope of this lab will ensure that we are
successful in connecting our networked RPi3 *Thing* controller, we are able to
log into the device, connect its file system to our development host (via sshfs)
and use the Atom editor to build our initial Python *Flask* Web Application.

The various steps of this lab are summarized as:
* Install Flask (lightweight Python Webserver)
* Ensure that we have ssh keys installed and sshfs operating smoothly.
* Build a Hello IoT WebApp using
* Run the Webserver from RPi3
* Test the Webserver from Browser and CLI

### Step 1: Getting Flask
```
pi$ pip install flask

```
### Step 2: Ensure ssh keys and sshfs operating smoothly
Secure shell (ssh) is the most universal and secure method to connect between
two computers, to transfer files (via the scp command) and to mount a
target's file system into the development host (via the sshfs command).

### Step 3: Build a Hello IoT App
Using the sshfs mounted folders and the Atom editor build the Flask demo
Web Application ```hello.py```.  This application will reply with a
simple HTML greeting page plus the hostname that was established during the
setup phase:

#### > Step 3a: Flask and socket
``` python
from flask import Flask
import socket
```

#### > Step 3b: Obtaining RPi Hostname from Socket Library
``` python
## Get my machine hostname
if socket.gethostname().find('.') >= 0:
    hostname=socket.gethostname()
else:
    hostname=socket.gethostbyaddr(socket.gethostname())[0]
```

#### > Step 3c: Create the Flash Webserver app
``` python
app = Flask(__name__)
```

#### > Step 3d: Establish the default "route"
``` python
@app.route("/")
def hello():
    return "Hello IoT World from RPi3: " + hostname
```

#### > Step 3e: Code to run server on port 5000
``` python
## Run the website and make sure to make
##  it externally visible with 0.0.0.0:5000 (default port)
if __name__ == "__main__":
    app.run(host='0.0.0.0')
```

### Start the webserver and run the hello.py app

```sh
pi$ python hello.py
 => runs the flask webserver from http://0.0.0.0, port 5000 for external access
```

### Test the hello.py WebApp from CLI and Remote Browser
```
pi$ curl http://0.0.0.0:5000
Hello IoT World from RPi3 (hostname) : iot8e3c.iot!

pi$ ifconfig | grep "inet addr"
 => inet addr:**192.168.10.19**  Bcast:192.168.10.255  Mask:255.255.255.0

host$ curl http://192.168.10.19:5000
=> Hello IoT World from RPi3 (hostname) : iot8e3c.iot!

host$ curl http://iot8e3c:5000
=> Hello IoT World from RPi3 (hostname) : iot8e3c.iot!
```

![HelloIoT](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/Hello-IoT_416x288.png)


[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)
[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)

### Part A - OO Python GPIO Driver ###
**Synopsis:** A good architectural design starts with partitioning the system
into components. One such component in our IoT system will be a GPIO interface
driver for the 3 LEDs and one pushbutton switch we have defined. We will design
methods for each of the actions and then a unit test to exercise each of these
methods with the target hardware on our RPi breadboard.

#### Step A1: Building a Simple GPIO Python Driver
**Objective:** We'll design a simple object oriented Python module to handle I/O
for our project.  Let's start by creating a file called ```gpio.py``` and
importing libraries we will need for handling Raspberry PI GPIO.
``` python
import RPi.GPIO as GPIO
```
Next we will define each of the pins we will use for the LEDs and SWITCH.
``` python
LED1_PIN    = 18    # cobbler pin 12 (GPIO18)
LED2_PIN    = 13    # cobbler pin 33 (GPIO13)
LED3_PIN    = 23    # cobbler pin 16 (GPIO23)
SWITCH_PIN  = 27    # cobbler pin 7  (GPIO27)
```
Next we'll declare the name of the class we will use to instantiate our GPIO
object from our web server code.
```python
class PiGpio(object):
    """Raspberry Pi Internet 'IoT GPIO'."""
```
We need to define what happens when we initialize the driver in an init method.
``` python
def __init__(self):
    GPIO.setwarnings(False)
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(LED1_PIN, GPIO.OUT)      # RED LED as output
    GPIO.setup(LED2_PIN, GPIO.OUT)      # GRN LED as output
    GPIO.setup(LED3_PIN, GPIO.OUT)      # BLU LED as output
    GPIO.setup(SWITCH_PIN, GPIO.IN)     # Switch as input w/pu
    GPIO.setup(SWITCH_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)
```

Next we need a GPIO method to handle reading of the input switch pin. Notice
that we will invert the logic of the pin due to the momentary switch circuit
that grounds out the input upon pressing the switch down.
``` python
def read_switch(self):
    """Read the switch state."""
    switch = GPIO.input(SWITCH_PIN)
    # invert because of active low momentary switch
    if (switch == 0):
        switch=1
    else:
        switch=0
    return switch
```

And finally, we need ```getter``` and ```setter``` methods for the LED control
for each of the 3 LEDs we have defined.
``` python
# set the particular LED to ON or OFF
def set_led(self, led, value):
    """Change the LED to the passed in value, '1 ON or '0' OFF."""
    if(led == 1):
        GPIO.output(LED1_PIN, value)
    if(led == 2):
        GPIO.output(LED2_PIN, value)
    if(led == 3):
        GPIO.output(LED3_PIN, value)

# get the state of an LED
def get_led(self, led):
    """Return the state value of the LED, '1' ON or '0' OFF."""
    if(led == 1):
        return GPIO.input(LED1_PIN)
    if(led == 2):
        return GPIO.input(LED2_PIN)
    if(led == 3):
        return GPIO.input(LED3_PIN)
```

#### Step A2: GPIO Driver Unit Test
**Objective:** In order to thoroughly test our ```gpio.py``` driver we need some
low level unit test code that can be run from the command line shell as follows
(along with its corresponding output):
``` sh
pi$ ./gpio_test.py

============ Switch: 0 ============
LED 1 ON (RED)
LED1: 1
LED2: 0
LED3: 0

LED 2 ON (GRN)
LED1: 1
LED2: 1
LED3: 0

LED 3 ON (BLU)
LED1: 1
LED2: 1
LED3: 1

LED 1 OFF (RED)
LED1: 0
LED2: 1
LED3: 1

LED 2 OFF (GRN)
LED1: 0
LED2: 0
LED3: 1

LED 3 OFF (BLU)
LED1: 0
LED2: 0
LED3: 0
```
We will start by importing our GPIO driver and the time function we will need
for some time delays.  Note also the inclusion of a "she-bang" which will be
used to turn this file into an executable by telling the Linux shell where to
find the Python program at ```/usr/bin/python```.

```python
#!/usr/bin/python
import time
from gpio import PiGpio
```

In order to test the driver, we will need to instantiate it.
```python
# create an instance of the pi gpio driver.
pi_gpio= PiGpio()
```

Next we will simply run a forever while loop to test each of the methods
```python
# Blink the LEDS forever.
print('Blinking all my LEDs in sequence (Ctrl-C to stop)...')
while True:
# Get the current switch state and print
    switch = pi_gpio.read_switch()
    print('\n============ Switch: {0} ============'.format(switch))

    print('\nLED 1 ON (RED)')
    pi_gpio.set_led(1,True)
    print('LED1: {0}'.format(pi_gpio.get_led(1)))
    print('LED2: {0}'.format(pi_gpio.get_led(2)))
    print('LED3: {0}'.format(pi_gpio.get_led(3)))
    time.sleep(1.0)

    print('\nLED 2 ON (GRN)')
    pi_gpio.set_led(2,True)
    print('LED1: {0}'.format(pi_gpio.get_led(1)))
    print('LED2: {0}'.format(pi_gpio.get_led(2)))
    print('LED3: {0}'.format(pi_gpio.get_led(3)))
    time.sleep(1.0)

    print('\nLED 3 ON (BLU)')
    pi_gpio.set_led(3,True)
    print('LED1: {0}'.format(pi_gpio.get_led(1)))
    print('LED2: {0}'.format(pi_gpio.get_led(2)))
    print('LED3: {0}'.format(pi_gpio.get_led(3)))
    time.sleep(1.0)


    print('\nLED 1 OFF (RED)')
    pi_gpio.set_led(1,False)
    print('LED1: {0}'.format(pi_gpio.get_led(1)))
    print('LED2: {0}'.format(pi_gpio.get_led(2)))
    print('LED3: {0}'.format(pi_gpio.get_led(3)))
    time.sleep(1.0)

    print('\nLED 2 OFF (GRN)')
    pi_gpio.set_led(2,False)
    print('LED1: {0}'.format(pi_gpio.get_led(1)))
    print('LED2: {0}'.format(pi_gpio.get_led(2)))
    print('LED3: {0}'.format(pi_gpio.get_led(3)))
    time.sleep(1.0)

    print('\nLED 3 OFF (BLU)')
    pi_gpio.set_led(3,False)
    print('LED1: {0}'.format(pi_gpio.get_led(1)))
    print('LED2: {0}'.format(pi_gpio.get_led(2)))
    print('LED3: {0}'.format(pi_gpio.get_led(3)))
    time.sleep(1.0)
```
In order to run this unit test from the command line it will need to be made
executable.
```sh
pi$ chmod +x gpio_test.py
```
Then it can be run using the "./" method of execution from the command line.

[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)
[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)

### Part B -  Simple Flask API Webserver ###
**Objective:** We will be using HTTP GET and POST APIs as our basic method of
interfacing between our Webapp and the Python sensor and actuator driver code.  
The following is just an exercise to focus on how APIs work and how to test them
from the CLI (bash shell).

#### Step B1: import Flask and request support
Open a new file called ```api_server.py``` and enter the following sections:
Import the same structure as ```hello.py``` but provide support for parsing
requests.  Get the hostname as well and instantiate the Flash app object.
Place the app.run at the bottom of the file.  We will add each API and perform
a CURL test on each as we add them.
```python
from flask import Flask, request
import socket

## Get my machine hostname
if socket.gethostname().find('.')>=0:
    hostname=socket.gethostname()
else:
    hostname=socket.gethostbyaddr(socket.gethostname())[0]

app = Flask(__name__)


... API routes to be added below

## Run the website and make sure to make
##  it externally visible with 0.0.0.0:5000 (default)
if __name__ == "__main__":
    app.debug = True
    app.run(host='0.0.0.0')
```

#### Step B2: Add and Test Routes/API types
Add API routes for DEFAULT and a basic GET REQUEST.
```python
#DEFAULT Route
# curl http://0.0.0.0:5000/
@app.route("/")
def hello():
    return "Hello API Server : Default Request from (hostname) : " + hostname + "!\n"

#GET REQUEST
# curl http://0.0.0.0:5000/getHello
@app.route('/getHello')
def getRequestHello():
    return "Hello API Server : GET Request!\n"
```

Test these first two APIs by CURLing their hostname:5000
```sh
host$ curl iot8e3c.home:5000
=> Hello API Server : Default Request from (hostname) : iot8e3c.home!

host$ curl iot8e3c.home:5000/getHello
=> Hello API Server : GET Request!
```

Now, let's add a HTTP POST API request. **Note:** you can just add in the new
and save and the Flask framework will automatically restart for you after
detecting a file change.
```python
#POST REQUEST
# curl --data 'mykey=FOOBAR' http://0.0.0.0:5000/createHello
# echo 'mykey={"name":"Gene Cernan","age":"82"}' | curl -d @- http://0.0.0.0:5000/createHello
@app.route('/createHello', methods = ['POST'])
def postRequestHello():
    mydata = request.data
    print "Data:" + mydata
    assert request.path == '/createHello'
    assert request.method == 'POST'
    data = str(request.form['mykey'])
    # import pdb; pdb.set_trace()
    return "Hello API Server : You sent a "+ request.method + \
            " message on route path " + request.path + \
            " \n\tData:" +  data + "\n"
```

Test the POST API by CURLing with a slightly different way of passing data. We
will explore a couple of methods:
```sh
host$ curl --data 'mykey=FOOBAR' iot8e3c:5000/createHello
=> Hello API Server : You sent a POST message on route path /createHello
	 Data:FOOBAR

host$ echo 'mykey={"name":"Gene Cernan","age":"82"}' | curl -d @- iot8e3c:5000/createHello
=> Hello API Server : You sent a POST message on route path /createHello
	 Data:{"name":"Gene Cernan","age":"82"}
```
**GREAT!** Now you are empowered to create all manner of GET and POST API calls.

[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)
[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)

### Part C -  GPIO Webserver ###
**Objective:** Now its time to flesh out our main web server application ```main.py```
that will serve as the main interface between our GPIO python driver and the HTML
webpage ```index.html```.

#### Step C1: import Flask and request support and main execution (bottom)
Let's start by importing our Flask framework as well as our GPIO driver module
and instantiating objects for each:
```python
from gpio import PiGpio
from flask import *

app = Flask(__name__)
pi_gpio = PiGpio()

... add APIs <here>

if __name__ == "__main__":
    app.run(host='0.0.0.0', debug=True)
```

#### Step C2: Default Route
Next we need to add the default route.  In other words, this is the route that
will be executed whenever the main webpage is rendered on port 5000.  Note that
this default webpage load also contains code to read the current state of the
hardware and place in some python local variables.  These variables are then
passed by some new variable namespace that will be passed to
a *template* ```index.html``` file (located in a templates directory off the
root directory).  As we will see shortly these variables are accessible to the
HTML document in a special embedded scripting syntax  {{ python code }} supported
by the Flask framework.
```python
@app.route("/")
def index():
    # create an instance of my pi gpio object class.
    pi_gpio = PiGpio()
    switch_state = pi_gpio.read_switch()
    led1_state = pi_gpio.get_led(1)
    led2_state = pi_gpio.get_led(2)
    led3_state = pi_gpio.get_led(3)
    return render_template('index.html', switch=switch_state,
                                led1=led1_state,
                                led2=led2_state,
                                led3=led3_state)
```

#### Step C3: Add all of our GPIO API Routes
```python
# ============================== API Routes ===================================
# ============================ GET: /leds/<state> =============================
# read the LED status by GET method from curl for example
# curl http://iot8e3c:5000/led/1
# curl http://iot8e3c:5000/led/2
# -----------------------------------------------------------------------------
@app.route("/leds/<int:led_state>", methods=['GET'])
def leds(led_state):
  return "LED State:" + str(pi_gpio.get_led(led_state)) + "\n"


# =============================== GET: /sw ====================================
# read the switch input by GET method from curl for example
# curl http://iot8e3c:5000/sw
# -----------------------------------------------------------------------------
@app.route("/sw", methods=['GET'])
def sw():
  return "Switch State:" + str(pi_gpio.read_switch()) + "!\n"

# ======================= POST: /ledcmd/<data> =========================
# set the LED state by POST method from curl. For example:
# curl --data 'led=1&state=ON' http://iot8e3c:5000/ledcmd
# -----------------------------------------------------------------------------
@app.route("/ledcmd", methods=['POST'])
def ledcommand():
    cmd_data = request.data
    print "LED Command:" + cmd_data
    led = int(str(request.form['led']))
    state = str(request.form['state'])
    if(state == 'OFF'):
        pi_gpio.set_led(led,False)
    elif (state == 'ON'):
        pi_gpio.set_led(led,True)
    else:
        return "Argument Error"

    return "Led State Command:" + state + " for LED number:"+ str(led) + "\n"
    # -----------------------------------------------------------------------------
# ============================== API Routes ===================================
```

#### Step C4: Test all of our API routes using CURL as indicated in comments.
```sh
# SW not pressed
host$ curl http://iot8e3c:5000/sw
=> Switch State:0!

# SW pressed
host$ curl http://iot8e3c:5000/sw
=> Switch State:1!

# LED GET requests
host$ curl http://iot8e3c:5000/leds/1
=> LED State:1

host$ curl http://iot8e3c:5000/leds/2
=> LED State:1

host$ curl http://iot8e3c:5000/leds/3
=> LED State:1

# Change the LED states to ON
host$ curl --data 'led=1&state=ON' http://iot8e3c:5000/ledcmd
=> Led State Command:ON for LED number:1

host$ curl --data 'led=2&state=ON' http://iot8e3c:5000/ledcmd
=> Led State Command:ON for LED number:2

host$ curl --data 'led=3&state=ON' http://iot8e3c:5000/ledcmd
=> Led State Command:ON for LED number:3

# Change the LED states to OFF
host$ curl --data 'led=1&state=OFF' http://iot8e3c:5000/ledcmd
=> Led State Command:ON for LED number:1

host$ curl --data 'led=2&state=OFF' http://iot8e3c:5000/ledcmd
=> Led State Command:ON for LED number:2

host$ curl --data 'led=3&state=OFF' http://iot8e3c:5000/ledcmd
=> Led State Command:ON for LED number:3
```

[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)
[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)

### Part D - Lab2 HTML Webpage ###
**Objective:** Now that we have our webserver api and driver architectural
components built and tested it's time to create our IoT website for driving
and providing status for our sensor / actuator system. Remember that this
webpage ```index.html``` has some slight non-HTML properties provided by the
Flask framework for embedded python execution using index.html as a template
(in the templates folder) and embedded code going into ```{{  code }}```
sections of the HTML.

#### Step D1: Create a Flask Templates Folder
Flask has this nice capability to intereact with HTML by placing your HTML code
into a directory right off the *root* webpage app.
```
pi$ cd Labs/Lab2/webapp
pi$ mkdir templates
pi$ cd templates
pi$ touch index.html   # creates a blank index.html to be edited in Atom
```

#### Step D2: Start by creating the basic HTML *standard* structure
A good way to enter HTML code is to use CodePen (codepen.io).  After you have
opened a free account you should prototype your code in CodePen using their
WYSIWYG web page rendering and HTML tidy and syntax checking utilities.  Start
by entering the basic html document structure PLUS a scripting area including
the jQuery *minified* javascript library as shown in the URL.
```html
<!doctype html>
<html>

  <head>
    <title>UW IoT Lab2</title>
  </head>

  <body>

    <!-- ... our HTML goes here!! -->

    <script src="https://code.jquery.com/jquery-1.12.0.min.js"></script>

    <script>
      <!-- ... our custom JS jQuery scripting goes here!! -->
    </script>

  </body>
</html>
```
Select ```Tidy HTML``` and ```Analyze HTML``` to clean up indents and spaces as
well as checking the syntax of your HTML code.  Then select-all and copy the
entire page and paste into your Atom editor (mapped into the RPi).You can go 
back and forth from your CodePen and Atom to copy-paste updates into the 
index.html located in the ```templates``` directory.

#### Step D3: Add python embedded script status structure
The state of the switch and LEDs will be read each time the web page loads if
we can embed a bit of Python into the HTML <body> code using {{ code }} methods.
Prototype this all in CodePen initially (and don't forget to rename and save
your *pen*).

```html
<h2>UW IoT | Lab 2: GPIO API and WebApp</h2>
<h3>Switch: {{'On' if switch else 'Off'}}</h3>
<h4>RED LED (on GPIO18): {{'ON' if led1 else 'OFF'}}</h4>
<h4>GREEN LED (on GPIO13): {{'ON' if led2 else 'OFF'}}</h4>
<h4>BLUE LED (on GPIO23): {{'ON' if led3 else 'OFF'}}</h4>
```
Refresh the webpage when pressing and releasing the SWITCH to see if the webpage
variables update as we expect.  You might try a few CURLs to manually change the
LED state and perform a similar reload to see if the LED states are picked up.

#### Step D4: Add html buttons (one for each LED)
Each HTML button will toggle the state of the LED if we just add an *id* to the
button so that the jQuery script code (below) will "find" that button by name.
```html
<p>
  <button type='button' id='red_led_btn'>RED LED</button><br><br>
  <button type='button' id='grn_led_btn'>GREEN LED</button><br><br>
  <button type='button' id='blu_led_btn'>BLUE LED</button><br><br>
</p>
```
Let's also add a little style to the buttons to give them some color corresponding
to the LED they control. Add the following ```style``` attribute to each of the
buttons and then change the background color to the corresponding LED color.
```html
  <button style="width:100px; height:50px; color:white; background:red" ... >
  <button style= ... >
  <button style= ... >
```
OK!  Done with the main HTML body code.  That's it for now in this section.

[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)
[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)

### Part E - Javascript Click Events ###
**Objective:** Now that we have almost everyone working, we need to add some
relatively simple jQuery to intercept button click events and then call the
GPIO methods by way of HTTP API methods.  In the ```<script>``` section, add the
following design pattern for each of the LEDs.  Even if you don't know much or
any jQuery you can sort of logically determine that an HTML element given by
the particular ID corresponding to the LED color will fire a button event which
will get processed by the jQuery JS click event.

```html
  <script>
  // start executing only after document has loaded
  $(document).ready(function() {
    // establish global variables for LED status
    var led1;
    var led2;
    var led3;

    // The button click functions run asynchronously in the browser
    $('#red_led_btn').click(function() {
      if (led1 === "OFF") {led1 = "ON";} else {led1 = "OFF";}
      var params = 'led=1&state='+led1;
      console.log('Led Command with params:' + params);
      $.post('/ledcmd', params, function(data, status){
              console.log("Data: " + data + "\nStatus: " + status);
      });
    });

    // code the green and blue buttons the same
  });
  </script>
```
Complete the same design pattern for each of the buttons but changing the POST
API data parameter to correspond to the correct LED.  Note that we have code for
toggling the led1 variable each time the click occurs.

[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)
[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)

### Part F - Fine-tune Startup Conditions
**Problem:** It turns out that there is a slight disconnect in state when the
web page has been reloaded after manipulating the LEDs from the buttons.

**Objective:** Because Javascript functions are by nature asynchronous, we can't
necessarily control the order of those functions firing.  However we need some
predictable start up sequencing when the HTML page loads and starts running the
script section of the code.  

#### Step F1: Build a Javascript function sequence in CodePen
We will use the jQuery Deferred execution model with 'resolve' and 'promise'
methods to synchronize the execution.
```javascript
function firstFunction() {
  var d = $.Deferred();
  // some very time consuming asynchronous code...
  setTimeout(function() {
    console.log('1');
    d.resolve();
  }, 1000);
  return d.promise();
}

function thirdFunction() {
  var d = $.Deferred();
  setTimeout(function() {
    console.log('3');
    d.resolve();
  }, 1000);
  return d.promise();
}

function secondFunction() {
  var d = $.Deferred();
  setTimeout(function() {
    console.log('2');
    d.resolve();
  }, 1000);
  return d.promise();
}

function fourthFunction() {
  var d = $.Deferred();
  // last function, not executed until the other 3 are done.
  setTimeout(function() {
    console.log('4');
    d.resolve();
  }, 1000);
  return d.promise();
}

// sequence through the synchronous functions using '.then'
firstFunction().then(thirdFunction).then(secondFunction).then(fourthFunction);
```

#### Step F2: Code a similar startup sequence for LED state variables
```javascript
// Let's read the current LED state
function initial_conditions() {
  var d = $.Deferred();

  setTimeout(function() {
    $.get('/leds/1',function(data){
      led1 = $.trim(data.split(':')[1]);
    });

    $.get('/leds/2',function(data){
      led2 = $.trim(data.split(':')[1]);
    });

    $.get('/leds/3',function(data){
      led3 = $.trim(data.split(':')[1]);
    });

    // console.log("Got my data now!");
    d.resolve();
  }, 1);
  return d.done();
}

// Let's initialize our LED vars to the current LED state "ON"/"OFF"
function led_status() {
  var d = $.Deferred();

  setTimeout(function() {
    if (led1 === '0') {led1 =  "OFF"} else {led1 =  "ON"}
    if (led2 === '0') {led2 =  "OFF"} else {led2 =  "ON"}
    if (led3 === '0') {led3 =  "OFF"} else {led3 =  "ON"}
    d.resolve();

    console.log("RED:",led1);
    console.log("GRN:",led2);
    console.log("BLU:",led3);
  }, 200);
  return d.promise();
}

// make sure to intialize synchronously (10ms back to back)
initial_conditions().then(led_status);
```
**Great!** We now have a fully functional sensor/actuator monitoring and control
dashboard webapp.  In our upcoming lab we will make this a more dynamic dashboard
that will automatically update indications using "Server Sent Events".


[LAB2 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/setup.md)
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up Lab2

### Objectives
For this lab we will continue building on our IoT webapp by adding basic GPIO
capability in a layered architectural manner.  We will build an object oriented
Python ```gpio.py``` driver as well as a unit test ```gpio_test.py``` for the
driver code.

We will also build a simple introduction to API design that provides a hands-on
approach to designing *HTTP get/post* methods within the Flask webserver
framework.

Next we'll build a simple ```index.html``` page that has three
buttons for toggling the LED states as well as an indicator for the state of
the switch.  This webpage will also have a small amount of Javascript (jQuery) to
handle pushbutton events.


The various steps of this lab are summarized as:
* [PART A](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/PartA.md) Design an object oriented Python GPIO driver and unit test.
* [PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/PartB.md) Build a Flask webserver application that shows how to build HTTP GET/POST API.
* [PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/PartC.md) Expand the API webserver design to interface to the GPIO module methods.
* [PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/PartD.md) Build our GPIO IoT Webapp and show how to interface it as a template to Flask.
* [PART E](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/PartE.md) Code each of the Javascript events that need handling from button clicks
* [PART F](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab2/PartF.md) Fine tune the Javascript logic to handle startup conditions
[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)

### Part A - Add Twitter Bootstrap Framework ###
**Synopsis:** A good website design provides for *separation of concerns*.  This
means that the HTML is generally separated from the CSS which is separated from
the JavaScript in so much as the code it placed in separate files and folders.

#### Step A1: Create Expanded Web File Structure
**Objective:** Flask provides for a traditional web site layout, where content (HTML)
is separated from presentation (CSS) and action (JavaScript) by placing each of
these files in their own separate folders. In addition to the ```templates```
folder we need to add a ```static``` folder and then add a ```css``` and ```js```
folder under the static *assets* folder.

```sh
pi$ cd ; cd Documents/GIT_REPOS/iot110/Labs
pi$ mkdir Lab3 ; cd Lab3
pi$ mkdir -p webapp/templates ; mkdir -p webapp/static/css ; mkdir -p webapp/static/js
pi$ cd webapp/static/css ; touch lab3.css
pi$ cd ../js ; touch lab3.js
```

#### Step A2: Download bootstrap and jQuery
**Objective:** We want to install the Bootstrap UI and components and put them
in our static assets folder. Use the links below to download the latest version
of Bootstrap and jQuery and then we will copy a few select files into the file
structure we created above.

[Download Bootstrap](http://getbootstrap.com/getting-started/#download)

The following is the jQuery site, but we will directly download using wget below:
[Download jQuery](http://jquery.com/download)

```sh
pi$ wget https://code.jquery.com/jquery-3.1.1.min.js
```
Now, let's grab two files from the Bootstrap download folder.  At the time of
this lesson it was /Downloads/bootstrap-3.3.7-dist/ (or wherever your Downloads
  folder happens to reside).

**Note:** The code below is copying from the HOST downloads folder thru the mount
point to the RPi's GIT repo mounted folder.  (Adjust this for  your unique
mount point situation)
```sh
host$ cd Downloads/bootstrap-3.3.7-dist
host$ cp css/bootstrap.min.css ~/PI_MOUNT_8e3c/iot110/Labs/Lab3/webapp/static/css/
host$ cp js/bootstrap.min.js ~/PI_MOUNT_8e3c/iot110/Labs/Lab3/webapp/static/js/

# Note: just as a reminder (MacOSX) the command for mounting your PI is
host$ sshfs pi@iot1234:Documents/GIT_REPOS PI_MOUNT_1234/ -C
```
#### Step A3:  
We will need to adjust the ```index.html``` meta and script sections to account
for our organization of the *web assets*.  Modify the HEAD section of the HTML
to make this change according to the Flask provisions for static assets.
```html
<head>
  <meta charset="utf-8">
    <title>UW IoT Lab3</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='css/bootstrap.min.css') }}">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='css/lab3.css') }}">
    <script src="{{ url_for('static',filename='js/jquery-3.1.1.min.js') }}"></script>
    <script src="{{ url_for('static',filename='js/bootstrap.min.js') }}"></script>
  </head>
```

OK, were done with the organization of our assets and prepared for styling with
Bootstrap components and actions.  Next we will move on to adding dynamic Server
Sent Events capability to our code.

[PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/PartB.md) Add additional
capbility to main.py for *Server Sent Events*.

[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)
[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)

### Part B - Adding SSE to the Webserver Code (main.py) ###
**Synopsis:** Flask has provisions built in to allow for streaming of data
from the server to clients.  We want to use that streaming capability to request
data from our GPIO driver and then send it through what Flask calls a ```Response```
mechanism.

#### Step B1: Timer
**Objective:** We will need to have a continuously running thread that updates
every half a second and sends updated state information on this endpoint.  
Therefore we will need to add the time library.  In addition we will use the
same library imports from the original web server implementation for GPIO.
```python
import time
from gpio import PiGpio
from debouncer import Debouncer
from flask import *

app = Flask(__name__)
pi_gpio = PiGpio()
db = Debouncer()
```

#### Step B2: SSE Endpoint
Next we need to add the routing endpoint code to read the switch status as well
as LEDs.  This endpoint will read the status of the switch, the 3 LEDs and then
build a data payload ```data: 0 1 0 1``` that will *yield* to the Flask Response
to communicate these data back to the web client. We will call this the myData
endpoint.  

```python
# =========================== Endpoint: /myData ===============================
# read the gpio states by GET method from curl for example
# curl http://iot8e3c:5000/myData
# -----------------------------------------------------------------------------
@app.route('/myData')
def myData():
    def get_state_values():
        while True:
            # return the yield results on each loop, but never exits while loop
            raw_switch = pi_gpio.read_switch()
            debounced_switch = str(db.debounce(raw_switch))
            led_red = str(pi_gpio.get_led(1))
            led_grn = str(pi_gpio.get_led(2))
            led_blu = str(pi_gpio.get_led(3))
            yield('data: {0} {1} {2} {3}\n\n'.format(debounced_switch,led_red,led_grn,led_blu))
            time.sleep(0.1)
    return Response(get_state_values(), mimetype='text/event-stream')
```

#### Step B3: SSE Client-side Subscriber
Now that we have a routing endpoint that creates an EventSource feed, we need a
client-side receiver of that data by matching up the method name with the
subscriber to that EventSource.  Below is a snippet of JavaScript that needs to
be at the bottom of index.html in order for it to receive data payloads.  We run
a simple test of this by logging output to the console.

```html
<script type="text/javascript">
  var switchSource = new EventSource("{{ url_for('myData') }}");
  switchSource.onmessage = function(e) {
    console.log(e.data);
  }
</script>
```

#### Step B4: Added Threaded Execution
Finally, because we want this thread to run independently from the other API
calls to this code, we need to simply tell the app.run method to ensure threaded
execution is enabled.  **Make sure this code is at the bottom of main.py**.

```python
if __name__ == "__main__":
    app.run(host='0.0.0.0', debug=True, threaded=True)
```

#### Step B5: Possible Errors with Threading
Whenever multiple threads are set up to run there's always the possibility that
the operating system will still be running that thread after killing the main
program.  For now, we will just manually kill these extra orphan threads by using
the Linux shell commands to list processes, obtain a process number and then to
kill off that extra process thread.  The symptom of this will be when you try to
run the main program again and then receive a *Traceback exception*.

Example:
```sh
pi$ python main.py
Traceback (most recent call last):
  File "main.py", line 82, in <module>
   ...
   socket.error: [Errno 98] Address already in use
```

To fix this we need to kill (using minus 9 for strong kill!) the orphan process.
```sh
pi$ ps aux | grep python
=> pi        3785  1.0  1.7  74788 16244 pts/0    Sl   18:15   0:04 /usr/bin/python main.py
=> pi        3900  0.0  0.2   4280  1908 pts/0    S+   18:22   0:00 grep --color=auto pytho
pi$ kill -9 3785

pi$ ps aux | grep python
=> pi        3902  0.0  0.1   4276  1876 pts/0    S+   18:22   0:00 grep --color=auto pytho
```

#### Step B6: Test from Chrome
Run through all of the states of the GPIO functionality by pulling up the
web developer console and observing the ```data: 0 1 0 1``` output that was
created from the console output above.

Now we are ready to start splitting off style and operations into their own
files also utilizing Bootstrap assets.

[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/PartC.md) Organize and Code Web Assets.

[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)
[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)

### Part C - Organize and Code Web Assets. ###
**Synopsis:** Before we finish up on the web JavaScript client side code and
styling via CSS, we want to better organize our assets by moving the scripts
into a separate file called ```js/lab3.js```.  We also want to create a style sheet
for this lab called ```css/lab3.css```.  The files go into their respective
folders under the ```static``` folder.

#### Step C1: Flask Parameter Passing w/o SSE
**Objective:** Flask uses a template engine called
[Jinja2](http://jinja.pocoo.org).  This framework is used to pass variables and
execute script code within HTML as it renders within a web browser.  
In our lab ```main.py``` web server the index.html is rendered on the default
path in the following code snippet.  The index() method is called when the web
page reloads on the default path ("/"). The default path is executed whenever a
CURL is executed (e.g. iot1234:5000) or when you type your host address into a
web browser URL address line (e.g. URL=>iot1234:5000). In our original main.py, in
the execution of index(), the GPIO driver is instantiated and the initial state 
of the led and switch variables are read and passed as arguments to 
the ```render_template()``` function.

```python
@app.route("/")
def index():
    # create an instance of my pi gpio object class.
    pi_gpio = PiGpio()
    switch_state = pi_gpio.read_switch()
    led1_state = pi_gpio.get_led(1)
    led2_state = pi_gpio.get_led(2)
    led3_state = pi_gpio.get_led(3)
    return render_template('index.html', switch=switch_state,
                                led1=led1_state,
                                led2=led2_state,
                                led3=led3_state)
```

#### Step C2: Flask Parameter Passing with SSE
In our new *Server Sent Event* implementation for this lab, we will push all of
this state information from the server by continuously reading the state. We will 
have a different mechanism for communicating and rendering the state to our web 
page using JavaScript.  This will simplify the index.html rendering code as 
follows:
```html
@app.route("/")
def index():
    return render_template('index.html')
```

#### Step C3: Adding the Client JavaScript Code to connect to SSE
In Part B we added an SSE data publishing endpoint to ```main.py``` and a simple
console.log() debug output of the client side subscription to this endpoint.  
Now we need that JavaScript, at the bottom of the index.html code, to change the
HTML code dynamically to reflect the state of the GPIO pins.  We start by
ensuring we have state variables for the leds that will be retained.  We read
and parse the incoming data and then call respective functions to update the
switch and leds on the HTML webpage.  These updates are accomplished using 
jQuery methods.  (e.g. the $().method capability we added in Part A).

```python
      /* start executing only after document has loaded */
      $(document).ready(function() {
        /* establish global variables for LED status */
        var led1;
        var led2;
        var led3;

 		/* var iotSource = new EventSource("{{ url_for('myData') }}"); */
        /* intercept the incoming states from SSE */
        iotSource.onmessage = function(e) {
          var params = e.data.split(' ');
          updateSwitch(params[0]);
          updateLeds(1,params[1]);
          updateLeds(2,params[2]);
          updateLeds(3,params[3]);
        }

        /* update the Switch based on its SSE state monitor */
        function updateSwitch(switchValue) {
          if (switchValue === '1') {
            $('#switch').text('ON');
          } else if (switchValue === '0') {
            $('#switch').text('OFF');
          }
        }

        /* update the LEDs based on their SSE state monitor */
        function updateLeds(ledNum,ledValue) {
          if (ledNum === 1) {
            if (ledValue === '1') {
              $('#red_led_label').text('ON');
              led1 = "ON"
            } else if (ledValue === '0') {
              $('#red_led_label').text('OFF');
              led1 = "OFF"
            }
          }
          else if (ledNum === 2) {
            if (ledValue === '1') {
              $('#grn_led_label').text('ON');
              led2 = "ON"
            } else if (ledValue === '0') {
              $('#grn_led_label').text('OFF');
              led2 = "OFF"
            }
          }
          else if (ledNum === 3) {
            if (ledValue === '1') {
              $('#blu_led_label').text('ON');
              led3 = "ON"
            } else if (ledValue === '0') {
              $('#blu_led_label').text('OFF');
              led3 = "OFF"
            }
          }
        }
```

At this point we have a fully functional page, but perhaps not a very 
esthetically pleasing dashboard.  In the next part we will fix that with the
Twitter Bootstrap framework we prepared in Part A.

[PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/PartD.md) Add Bootstrap UI Elements and CSS Styles.

[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)
[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)


### Part D - Add Bootstrap UI Elements and CSS Styles. ###
**Synopsis:** Adding Bootstrap.  We will add the following modifications to our
main index.html file to be compatible with Bootstrap UI.  

```html
<body>
  <div class="container panel">
    <div class="container well well-sm">
      <h3 id='title'>Lab 3 GPIO Server Sent Events</h3>
    </div>

    <div class="container well">
      <div class="row">
        <div class="col-sm-2"></div>
        <div class="col-sm-3">
          <h4 class="gpio">Switch</h4>
        </div>
        <div class="col-sm-3 switch">
          <h4><span id="switch" class="label label-default">&#9759</span></h4>
        </div>
        <div class="col-sm-2">
          <h4 class="gpio">[GPIO27]</h4></div>
        <div class="col-sm-2"></div>
      </div>

      <!-- LED: RED -->
      <div class="row">
        <div class="col-sm-2"></div>

        <div class="col-sm-3 led_button">
          <button type='button' id="red_led_btn" class="btn btn-md btn-default">Toggle LED</button>
        </div>
        <div class="col-sm-3 led_label">
          <h4><span id="red_led_label" class="label label-default">&#9728</span></span></h4>
        </div>
        <div class="col-sm-2">
          <h4 class="gpio">[GPIO18]</h4></div>
        <div class="col-sm-2"></div>
      </div>
      <!-- LED: GREEN -->
      <div class="row">
        <div class="col-sm-2"></div>

        <div class="col-sm-3 led_button">
          <button type='button' id="grn_led_btn" class="btn btn-md btn-default">Toggle LED</button>
        </div>
        <div class="col-sm-3 led_label">
          <h4><span id="grn_led_label" class="label label-default">&#9728</span></h4>
        </div>
        <div class="col-sm-2">
          <h4 class="gpio">[GPIO13]</h4></div>
        <div class="col-sm-2"></div>
      </div>
      <!-- LED: BLUE -->
      <div class="row">
        <div class="col-sm-2"></div>
        <div class="col-sm-3 led_button">
          <button type='button' id="blu_led_btn" class="btn btn-md btn-default">Toggle LED</button>
        </div>
        <div class="col-sm-3 led_label">
          <h4><span id="blu_led_label" class="label label-default">&#9728</span></h4>
        </div>
        <div class="col-sm-2">
          <h4 class="gpio">[GPIO23]</h4></div>
        <div class="col-sm-2"></div>
      </div>
    </div>
  </div>

  <script type="text/javascript">
    var iotSource = new EventSource("{{ url_for('myData') }}");
    // intercept the incoming states from SSE
  </script>
</body>
```

Now, we will add our Cascading Style Sheet styling to our site.  

```css
body {
  background-color: rgb(51, 0, 111);
  width: 800px;
  margin:5px auto;
}

span.label  {
    font-size: 1.3em;
}

.btn {
  font-size: 1.2em;
}

button {
  margin: 5 auto;
}

h4.gpio {
  margin:13 auto;
}
.well {
  width: 100%;
}

.well-sm {
  margin: 10px auto;
}

.panel {
  background-color: darkgray;
  width: 75%;
  text-align: center;
}
```

[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)
[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)


### Part E - Digital Debouncer. ###
**Synopsis:** In this section we will be adding a digital switch debouncer.

### Part E1 - Digital Debounce Module ###
**Objective:** We would like to have a digital debounce stand along class that
we can call from our server SSE section that is constantly sampling the switch
input.  Create a new file called ```debouncer.py```.  In this file we will
implement a digital shift register to debounce a stream of incoming raw switch
states.  We'll only make this a 4 bit shift register since the switch sampling
rate will be 100ms.

```python
SHIFT_MASK = 15
class Debouncer(object):
    """Shift Register Debouncer"""

    def __init__(self):
        self.switch_shift_register = 0

    # perform AND logic debouncer
    def debounce(self, switch_in):
        self.switch_shift_register = (self.switch_shift_register << 1) | switch_in
        return int((self.switch_shift_register & SHIFT_MASK) == SHIFT_MASK)
```

### Part E2 - Digital Debounce Unit Test ###
**Objective:** Let's create a unit test before we just embedded our new Module
into our web server.  It will be called ```debouncer_test.py```.  In this file
we will sample the raw switch state and pass it to the debouncer.  We'll use the
LEDs to show both the state of the raw and debounced output.
```python
#!/usr/bin/python
import time
from debouncer import Debouncer
from gpio import PiGpio

# create an instance of the pi gpio driver.
pi_gpio= PiGpio()
# create an instance of the switch debouncer
db = Debouncer()
#
print('Debounce my Input Switch (Ctrl-C to stop)...')
while True:
    switch_raw = pi_gpio.read_switch()
    switch_debounced = db.debounce(switch_raw)
    pi_gpio.set_led(1,(switch_raw == 1))
    pi_gpio.set_led(2,(switch_debounced == 1))

    print('SW RAW: {0} SW DEBOUNCED: {1}'.format(switch_raw , switch_debounced))
    time.sleep(0.2)
```

OK, now that our debouncer is working, we can implement it in the web server.

[LAB3 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/setup.md)
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up Lab3

### Objectives
For this lab we will continue building on our IoT webapp by adding *Advanced*
GPIO capability to get us started using *Server Sent Events* in Python/Flask.  We
will also spruce up our web page a bit using the Twitter *bootstrap* web
framework and the adjust the size and spacing to fit on the RPI just in case
you want to see it stand alone on the RPi's smaller own web browser screen.

The various steps of this lab are summarized as:
* [PART A](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/PartA.md) Add Twitter Bootstrap Framework.
* [PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/PartB.md) Add additional
capbility to main.py for *Server Sent Events*.
* [PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/PartC.md) Organize and Code Web Assets.
* [PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/PartD.md) Add Bootstrap UI Elements and CSS Styles.
* [PART E](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab3/PartE.md) Digital Debounce.

[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)
[LAB4 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/setup.md)

## Part A
**Synopsis:** We need to ensure that the I2C serial bus capability is enabled and
functional with its connection to the BMP280 pressure/temperature sensor.  We
will enable the I2C from RPi settings and then install some ```i2c-tools``` to scan
all of the I2C addresses for the presence of the BMP280.   From the BMP280
datasheet we know that the I2C bus address is either 0x76 (SDO grounded) or 0x77
(SDO connected high or left floating).  This will show up and be apparent using
the ```i2cdetect``` utility.

## Objectives
* Enabling I2C Bus Capability on RPI
* Wire the BMP280 into the breadboard
* Test to ensure proper connectivity

*Note:* We'd like to thank **Matt Hawkins** for his excellent tutorial on using Python
for many sensor devices on RPI and his example code for the BME280 (similar device to the BMP280).

[Python Driver BME280](http://www.raspberrypi-spy.co.uk/2016/07/using-bme280-i2c-temperature-pressure-sensor-in-python/)<br />
[Enable I2C Interface](http://www.raspberrypi-spy.co.uk/2014/11/enabling-the-i2c-interface-on-the-raspberry-pi/)<br />
[BMP280 Datasheet](https://cdn-shop.adafruit.com/datasheets/BST-BMP280-DS001-11.pdf)<br />

## Enabling I2C Bus Capability on RPI

### Step A1: Enable i2c using raspi-config utility
```
pi$ sudo raspi-config
```
Now complete the following steps :

* Select Advanced Options
* Select I2C

The screen will ask if you want the ARM I2C interface to be enabled :

* Select Yes
* Select Ok (Enable I2C)
* Select Ok (Install Kernel Modules)
* Select Finish to return to the command line.
* Select Reboot

### Step A2: Enable i2c using RPi Preferences Panel
Go to Menu > Preferences > Raspberry Pi Configuration and select the Intefaces Tab
<img src="https://gitlab.com/iot110/iot110-student/raw/master/Labs/Lab4/images/I2C_800x480.png" alt="I2C Enable">

### Step A3:  Install I2C Utilities

```
pi$ sudo apt-get update
pi$ sudo apt-get install -y python-smbus i2c-tools
```

### Step A4: Reboot and Test I2C
```
pi$ sudo reboot   
  => wait until rebooted
pi$ lsmod | grep i2c_
i2c_bcm2708             4834  0
i2c_dev                 5859  0
```
That will list all the modules starting with i2c_. If it lists i2c_bcm2708 then the module is running correctly.

### Step A5: Wire the BMP280 on the Breadboard
The following breadboard configuration will be used to test the BMP280.  Please
add the BMP280 module and connect as showing below.
![Lab4 Breadboard](https://gitlab.com/iot110/iot110-student/raw/master/Labs/Lab4/images/Lab4-Breadboard.png)

### Step A6: Test the I2C Address
Open the [BMP280 Datasheet](https://cdn-shop.adafruit.com/datasheets/BST-BMP280-DS001-11.pdf) and browse to section **5.2 IC Interface**<br />

The **IC interface** uses the following pins:
* SCK: serial clock (SCL)
* SDI: data (SDA)
* SDO: Slave address LSB (GND = 0, VDDIO = 1)

"...The 7-bit device address is 111011x. The 6 MSB bits are fixed. The last bit is changeable by
SDO value and can be changed during operation. Connecting SDO to GND results in slave
address 1110110 (**0x76**); connection it to VDDIO results in slave address 1110111 (**0x77**), which is the same as BMP180s IC address. The SDO pin cannot be left floating; if left floating, the
IC address will be undefined."

**Connect SDO to 10K PU**
```
pi$ sudo i2cdetect -y 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
70: -- -- -- -- -- -- 77 --
```

**Connect SDO to GND**

```
pi$ sudo i2cdetect -y 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
70: -- -- -- -- -- -- 76 --
```

[PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/PartB.md) Create BMP280 Driver

[LAB4 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/setup.md)
[LAB4 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/setup.md)

## BMP280 Driver Development

## Objectives
* Adapt low level driver for bmp280 (from Matt Hawkins' site)

*Note:* We'd like to thank **Matt Hawkins** for his excellent tutorial on using Python
for many sensor devices on RPI and his example code for the BME280 (similar device to the BMP280).

### Step B1  Imports and the Python SHEBANG
```python
#!/usr/bin/python
# =============================================================================
#        File : bmp280.py
# Description : Read data from the Bosch digital pressure sensor.
#      Author : S. Dame (Adapted from Matt Hawkins' code)
#        Date : 12/21/2016
# =============================================================================
#
#  Official datasheet available from :
#  https://www.bosch-sensortec.com/bst/products/all_products/bme280
#
# Matt Hawkin's site --> http://www.raspberrypi-spy.co.uk/
# =============================================================================
import smbus    # System Management Bus
import time     # time utilities

```

### Step B2  FFI Interface to some C types needed for byte manipulation
```python
# =============================================================================
# ctypes is an advanced ffi (Foreign Function Interface) package for Python
# that provides  call functions in dlls/shared libraries and has extensive
# facilities to create, access and manipulate simple and complicated
# C data types in Python
# =============================================================================
from ctypes import c_short
from ctypes import c_byte
from ctypes import c_ubyte
# =============================================================================
```

### Step B3  Collection of Utility Functions
```python
def getShort(data, index):
  # return two bytes from data as a signed 16-bit value
  return c_short((data[index+1] << 8) + data[index]).value

def getUShort(data, index):
  # return two bytes from data as an unsigned 16-bit value
  return (data[index+1] << 8) + data[index]

def getChar(data,index):
  # return one byte from data as a signed char
  result = data[index]
  if result > 127:
    result -= 256
  return result

def getUChar(data,index):
  # return one byte from data as an unsigned char
  result =  data[index] & 0xFF
  return result
```

### Step B4  Sensor Object Constructor and read ID Method
```python
# =============================================================================
# create a sensor object
# -----------------------------------------------------------------------------
class PiBMP280(object):
    """Raspberry Pi 'IoT BMP280 Sensor'."""

    # addr = I2C Chip Address
    def __init__(self,addr=DEVICE):
        self.bus = smbus.SMBus(1)   # Rev 2 Pi, Pi 2 & Pi 3 uses bus 1
                                    # Rev 1 Pi uses bus 0
        self.addr = addr            # register the address with the object

    def readBMP280ID(self):
      REG_ID     = 0xD0
      (chip_id, chip_version) = self.bus.read_i2c_block_data(self.addr, REG_ID, 2)
      return (chip_id, chip_version)
```

### Step B5.1  Read Pressure/Temperature Method (setup)
```python
    def readBMP280All(self, addr=DEVICE):
      # Register Addresses
      REG_DATA = 0xF7
      REG_CONTROL = 0xF4
      REG_CONFIG  = 0xF5

      # Oversample setting - page 27
      OVERSAMPLE_TEMP = 2
      OVERSAMPLE_PRES = 2
      MODE = 1
      
      # write oversample configuration and mode
      control = OVERSAMPLE_TEMP<<5 | OVERSAMPLE_PRES<<2 | MODE
      self.bus.write_byte_data(self.addr, REG_CONTROL, control)

      # Read blocks of calibration data from EEPROM
      # See Page 22 data sheet
      cal1 = self.bus.read_i2c_block_data(self.addr, 0x88, 24)
      cal2 = self.bus.read_i2c_block_data(self.addr, 0xA1, 1)
      cal3 = self.bus.read_i2c_block_data(self.addr, 0xE1, 7)
      
      # ... continued ...
```

### Step B5.2  Set up T and P Compensation values
```python
      # Convert byte data to word values
      dig_T1 = getUShort(cal1, 0)
      dig_T2 = getShort(cal1, 2)
      dig_T3 = getShort(cal1, 4)

      dig_P1 = getUShort(cal1, 6)
      dig_P2 = getShort(cal1, 8)
      dig_P3 = getShort(cal1, 10)
      dig_P4 = getShort(cal1, 12)
      dig_P5 = getShort(cal1, 14)
      dig_P6 = getShort(cal1, 16)
      dig_P7 = getShort(cal1, 18)
      dig_P8 = getShort(cal1, 20)
      dig_P9 = getShort(cal1, 22)

      dig_H1 = getUChar(cal2, 0)
      dig_H2 = getShort(cal3, 0)
      dig_H3 = getUChar(cal3, 2)

      dig_H4 = getChar(cal3, 3)
      dig_H4 = (dig_H4 << 24) >> 20
      dig_H4 = dig_H4 | (getChar(cal3, 4) & 0x0F)

      dig_H5 = getChar(cal3, 5)
      dig_H5 = (dig_H5 << 24) >> 20
      dig_H5 = dig_H5 | (getUChar(cal3, 4) >> 4 & 0x0F)

      dig_H6 = getChar(cal3, 6)

      # ... continued ...      
```

### Step B5.3  Read Temperature and Pressure Raw Values
```python
      # Read temperature & pressure
      data = self.bus.read_i2c_block_data(self.addr, REG_DATA, 6)
      pres_raw = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4)
      temp_raw = (data[3] << 12) | (data[4] << 4) | (data[5] >> 4)
      # ... continued ...      
```

### Step B5.4  Perform Compensation and calc values in degrees C and hPa Units
```python
      # Refine temperature based on calibration per spec
      var1 = ((((temp_raw>>3)-(dig_T1<<1)))*(dig_T2)) >> 11
      var2 = (((((temp_raw>>4) - (dig_T1)) * ((temp_raw>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14
      t_fine = var1+var2
      temperature = float(((t_fine * 5) + 128) >> 8);

      # Refine pressure and adjust for temperature
      var1 = t_fine / 2.0 - 64000.0
      var2 = var1 * var1 * dig_P6 / 32768.0
      var2 = var2 + var1 * dig_P5 * 2.0
      var2 = var2 / 4.0 + dig_P4 * 65536.0
      var1 = (dig_P3 * var1 * var1 / 524288.0 + dig_P2 * var1) / 524288.0
      var1 = (1.0 + var1 / 32768.0) * dig_P1
      if var1 == 0:
        pressure=0
      else:
        pressure = 1048576.0 - pres_raw
        pressure = ((pressure - var2 / 4096.0) * 6250.0) / var1
        var1 = dig_P9 * pressure * pressure / 2147483648.0
        var2 = pressure * dig_P8 / 32768.0
        pressure = pressure + (var1 + var2 + dig_P7) / 16.0

      return temperature/100.0,pressure/100.0
# -----------------------------------------------------------------------------      
# =============================================================================
```

### Step B5.4  Add a default CLI main function to bmp280.py
```python
# =============================================================================
# main to test from CLI
def main():

    # create an instance of my pi bmp280 sensor object
    pi_bmp280 = PiBMP280()

    # Read the Sensor ID.
    (chip_id, chip_version) = pi_bmp280.readBMP280ID()
    print "    Chip ID :", chip_id
    print "    Version :", chip_version

    # Read the Sensor Temp/Pressure values.
    (temperature, pressure) = pi_bmp280.readBMP280All()
    print "Temperature :", temperature, "C"
    print "   Pressure :", pressure, "hPa"

if __name__=="__main__":
   main()
```
[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/PartC.md) Create BMP280 Unit Test

[LAB4 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/setup.md)
[LAB4 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/setup.md)

## Setting up BMP280 Unit Test

## Objectives
* Create unit test for checking out Methods of BMP280
* Create unit test for abstract methods of multiple BMP280 sensors.

### Step C1  imports
```python
import pprint
from bmp280 import PiBMP280

```


### Step C2  Array of BMP280 Sensor Parameters
```python
# create an array of my pi bmp280 sensor dictionaries
sensor = []
sensor.append({'name' : 'bmp280', 'addr' : 0x76, 'chip' : PiBMP280(0x76) , 'data' : {}})

```


### Step C3  Get Sensor ID Populated
```python
# Read the Sensor ID for 0x76 -> values into the ['data'] dictionary
(chip_id, chip_version) = sensor[0]['chip'].readBMP280ID()
sensor[0]['data']['chip_id'] = chip_id
sensor[0]['data']['chip_version'] = chip_version
```

### Step C1  Get the Sensor Data and print the Object
```python
print "  ============================== SENSOR   =============================="
print "  Chip ADDR :", hex(sensor[0]['addr'])
print "    Chip ID :", sensor[0]['data']['chip_id']
print "    Version :", sensor[0]['data']['chip_version']

# Read the Sensor Temp/Pressure values into the ['data'] dictionary
(temperature, pressure) = sensor[0]['chip'].readBMP280All()
sensor[0]['data']['temperature'] = { 'reading': temperature, 'units' : 'C' }
sensor[0]['data']['pressure'] = { 'reading': pressure, 'units' : 'hPa' }

print "Temperature :", sensor[0]['data']['temperature']['reading'], "C"
print "   Pressure :", sensor[0]['data']['pressure']['reading'] , "hPa"

pprint.pprint(sensor[0])
print "  ======================================================================"

```

[PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/PartD.md) Test Everything

[LAB4 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/setup.md)
[LAB4 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/setup.md)

## Perform BMP280 Unit Tests

## Objectives
* Run unit test for ```bmp280.py``` stand alone
* Run unit test for abstract test methods of multiple BMP280 sensors.

### Step D1  set up Unit Tests for them to become executables
```sh
pi$ chmod +x bmp280.py
pi$ chmod +x bmp280_test.py
pi$ chmod +x bmp280_test2.py
```
### Step D2  Test the methods in bmp280.py
```sh
pi$ ./bmp280.py
    Chip ID : 88
    Version : 1
Temperature : 23.61 C
   Pressure : 1009.74418394 hPa
```

### Step D3  One sensor test in bmp280_test.py
```sh
pi$ ./bmp280_test.py
============================== SENSOR 1 ==============================
Chip ADDR : 0x76
  Chip ID : 88
  Version : 1
Temperature : 23.61 C
 Pressure : 1009.71752441 hPa
{'addr': 118,
'chip': <bmp280.PiBMP280 object at 0x76a887b0>,
'data': {'chip_id': 88,
        'chip_version': 1,
        'pressure': {'reading': 1009.7175244112908, 'units': 'hPa'},
        'temperature': {'reading': 23.61, 'units': 'C'}},
'name': 'bmp280'}
======================================================================
```

### Step D4  Two sensor test in bmp280_test2.py
```sh
============================== SENSOR 1 ==============================
Chip ADDR : 0x76
  Chip ID : 88
  Version : 1
Temperature : 23.61 C
 Pressure : 1009.71752441 hPa
{'addr': 118,
'chip': <bmp280.PiBMP280 object at 0x76a887b0>,
'data': {'chip_id': 88,
        'chip_version': 1,
        'pressure': {'reading': 1009.7175244112908, 'units': 'hPa'},
        'temperature': {'reading': 23.61, 'units': 'C'}},
'name': 'bmp280'}
============================== SENSOR 2 ==============================
Chip ADDR : 0x77
  Chip ID : 88
  Version : 1
Temperature : 23.59 C
 Pressure : 1009.7345 hPa
{'addr': 118,
'chip': <bmp280.PiBMP280 object at 0x76a887b0>,
'data': {'chip_id': 88,
        'chip_version': 1,
        'pressure': {'reading': 1009.7345, 'units': 'hPa'},
        'temperature': {'reading': 23.59, 'units': 'C'}},
'name': 'bmp280'}
======================================================================
```

[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/PartC.md) Back to Part C

[LAB4 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/setup.md)
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up Lab4

### Objectives
For this lab we will continue building on our IoT suite by adding our first
active sensor device.  We will be adding the *Bosch BMP280* Pressure/Temperature
sensor and interfacing to it using the I2C serial protocol standardized by
Philips (NXP) Semiconductor.  

The various steps of this lab are summarized as:
* [PART A](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/PartA.md) Enable I2C Bus and Test Connection to BMP280
* [PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/PartB.md) Create BMP280 Python Driver
* [PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/PartC.md) Create BMP280 Python Driver Unit Test
* [PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab4/PartD.md) Test Everything

[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)
[LAB5 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/setup.md)

## Part A - Create a Sensor Data Object
**Synopsis:** We need to enhance our ```main.py``` to blend in the capability
we developed in Lab4 unit tests to gather data from our sensor device 

## Objectives
* Merge code from Lab3 and Lab4
* Rename lab3.css and lab3.js
* Add Python Data Object to main.py for our BMP280 Sensor
* Add a console test in lab5.js

### Step A1: Copy Select Files from Lab3 and Lab4
```sh
pi$ cd ~/Documents/GIT_REPOS/iot110/Labs
pi$ cp -r Lab3/ Lab5/
pi$ cp Lab4/bmp280.py Lab5/webapp/
pi$ cd Lab5/webapp/
```

### Step A2: Test to ensure BMP280 and bmp280.py are working
```sh
$ ./bmp280.py 
    Chip ID : 88
    Version : 1
Temperature : 25.21 C
   Pressure : 1018.92606166 hPa
```

### Step A3: Modify main.py to add Python Sensor Object for BMP280.py
Import the bmp280 module
```python
#!/usr/bin/python
import time
from gpio import PiGpio
from bmp280 import PiBMP280
from debouncer import Debouncer
from flask import *
```

Create GPIO, Debounce and Sensor Objects
```python
# create GPIO Object and Switch Debouncer
pi_gpio = PiGpio()
db = Debouncer()
# create an array of my pi bmp280 sensor dictionaries
sensor = {"name" : "bmp280", "addr" : 0x76, "chip" : PiBMP280(0x76) , "data" : {}}
(chip_id, chip_version) = sensor["chip"].readBMP280ID()
sensor["data"]["chip_id"] = chip_id
sensor["data"]["chip_version"] = chip_version
```

Create a function to get only the temperature and pressure sensor values.
```python
# ============================== Functions ====================================
def get_sensor_values():
    (temperature, pressure) = sensor["chip"].readBMP280All()
    sensor["data"]["temperature"] = { "reading": temperature, "units" : "C" }
    sensor["data"]["pressure"] = { "reading": pressure, "units" : "hPa" }
    return sensor["data"]
```

All API methods for GPIO and LEDs remain unchanged
```python
# ============================== API Routes ===================================
app = Flask(__name__)

@app.route("/")
def index():
    return render_template('index_bs.html')
    # create an instance of my pi gpio object class.
    # pi_gpio = PiGpio()
    # switch_state = pi_gpio.read_switch()
    # led1_state = pi_gpio.get_led(1)
    # led2_state = pi_gpio.get_led(2)
    # led3_state = pi_gpio.get_led(3)
    # return render_template('index.html', switch=switch_state,
    #                             led1=led1_state,
    #                             led2=led2_state,
    #                             led3=led3_state)
# ============================ GET: /leds/<state> =============================
# read the LED status by GET method from curl for example
# curl http://iot8e3c:5000/leds/1
# curl http://iot8e3c:5000/leds/2
# curl http://iot8e3c:5000/leds/3
# -----------------------------------------------------------------------------
@app.route("/leds/<int:led_state>", methods=['GET'])
def leds(led_state):
  return "LED State:" + str(pi_gpio.get_led(led_state)) + "\n"


# =============================== GET: /sw ====================================
# read the switch input by GET method from curl for example
# curl http://iot8e3c:5000/switch
# -----------------------------------------------------------------------------
@app.route("/sw", methods=['GET'])
def sw():
  return "Switch State:" + str(pi_gpio.read_switch()) + "!\n"

# ======================= POST: /ledcmd/<data> =========================
# set the LED state by POST method from curl. For example:
# curl --data 'led=1&state=ON' http://iot8e3c:5000/ledcmd
# -----------------------------------------------------------------------------
@app.route("/ledcmd", methods=['POST'])
def ledcommand():
    cmd_data = request.data
    print "LED Command:" + cmd_data
    led = int(str(request.form['led']))
    state = str(request.form['state'])
    if(state == 'OFF'):
        pi_gpio.set_led(led,False)
    elif (state == 'ON'):
        pi_gpio.set_led(led,True)
    else:
        return "Argument Error"

    return "Led State Command:" + state + " for LED number:"+ str(led) + "\n"
# -----------------------------------------------------------------------------
```

### Step A4: Refactor the data yield route for the SSE to send the Sensor Object
```python
# =========================== Endpoint: /myData ===============================
# read the gpio states by GET method from curl for example
# curl http://iot8e3c:5000/myData
# -----------------------------------------------------------------------------
@app.route('/myData')
def myData():
    def get_state_values():
        while True:
            # return the yield results on each loop, but never exits while loop
            raw_switch = pi_gpio.read_switch()
            debounced_switch = str(db.debounce(raw_switch))
            data_obj = get_sensor_values()
            data_obj["led_red"] = str(pi_gpio.get_led(1))
            data_obj["led_grn"] = str(pi_gpio.get_led(2))
            data_obj["led_blu"] = str(pi_gpio.get_led(3))
            data_obj["switch"] = debounced_switch
            yield('data: {0}\n\n'.format(data_obj))
            time.sleep(1.0)
    return Response(get_state_values(), mimetype='text/event-stream')
# ============================== API Routes ===================================
```
   

Ensure app.run is the last thing in the code.
```python
if __name__ == "__main__":
    app.run(host='0.0.0.0', debug=True, threaded=True)
```

[PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/PartB.md) Send the Sensor Data Object to the Webapp

[LAB5 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/setup.md)
[LAB5 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/setup.md)

## Part B - Send the Sensor Data Object to the Webapp
**Synopsis:** In order to communicate sensor data from our Python driver program
and main web server, we need to package it in a Python dictionary structure and 
sent it via Server Sent Events as a single data item and then decode it into a
JavaScript Object.

## Objectives
* Point to new lab5.css and lab5.js file after renaming them for Lab5
* Test that the single quoted text sensor structure arrives at the web
* Convert single quoted strings to double quoted (required by JSON.parse)
* Convert the sensor JSON data into a JavaScript object

### Step B1: Adjust index.html <head> section for lab5.css and lab5.js name change
```
<head>
  <meta charset="utf-8">
  <title>UW IoT Lab5</title>
  <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='css/bootstrap.min.css') }}">
  <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='css/lab5.css') }}">
  <script src="{{ url_for('static',filename='js/jquery-3.1.1.min.js') }}"></script>
  <script src="{{ url_for('static',filename='js/bootstrap.min.js') }}"></script>
  <script src="{{ url_for('static',filename='js/lab5.js') }}"></script>
</head>
```

### Step B2: Adjust lab5.js iotSource.onmessage function for initial test
```python
iotSource.onmessage = function(e) {
  console.log(e.data);
}
```

### Step B3: Start Webserver and Verify that IoT sensor text data is sent
Start Webserver
```sh
pi$ ./main.py
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger pin code: 269-766-075
   192.168.1.17 - - [11/Feb/2017 17:14:34] "GET /myData HTTP/1.1" 200 -
```

Using Google Chrome Developer Tools (right click 'inspect') observe console
The following should be what the text version of the sensor object looks like.
```
{'led_red': '1', 'chip_id': 88, 'led_grn': '1', 'temperature': {'units': 'C', 'reading': 25.41}, 'chip_version': 1, 'pressure': {'units': 'hPa', 'reading': 1018.8871169722084}, 'switch': '0', 'led_blu': '1'}

```
### Step B4: convert the sensor JSON data into a JavaScript object
```JavaScript
iotSource.onmessage = function(e) {
  // must convert all single quoted data with double quote format
  var dqf = e.data.replace(/'/g, '"');
  // now we can parse into JSON
  d = JSON.parse(dqf);
  console.log(d);
}
```

Verify that we now have a JavaScript representation of the sensor object in the
Chrome Console.
![JavaScript Object](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/JS_SensorObject.png)


[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/PartC.md) Display Time, Temp and Pressure in a Bootstrap Table Structure

[LAB5 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/setup.md)
[LAB5 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/setup.md)

## Part C - Display Time, Temp and Pressure in a Bootstrap Table Structure
**Synopsis:** We now need to add a few new JavaScript libraries and stylesheets
in order to spruce up our user interface for displaying data. 

## Objectives
* Download jQuery-UI, RaphaelJS and MorrisJS and install in static assets
* Configure a "Tabbed" Panel for our Data Dashboard
* Shrink and Optimize the LED and Switch Dashboard
* JavaScript array object to handle data feed

### Step C1: Download Tools (JS and CSS) jQuery-UI, RaphaelJS and MorrisJS
Download the above libraries and copy the ```min.css``` and ```min.js``` files 
(if ```minified``` is availabl) into the static assets folder. The folder should 
look like this after downloading and copying assets from the above libaries:

```
pi$ ls -l static/css/
total 176
-rw-r--r-- 1 pi pi 121200 Feb 11 16:38 bootstrap.min.css
-rw-r--r-- 1 pi pi  32076 Sep 14 18:34 jquery-ui.min.css
-rw-r--r-- 1 pi pi  13849 Sep 14 18:34 jquery-ui.theme.min.css
-rw-r--r-- 1 pi pi    986 Feb 12 10:22 lab5.css
-rwxr-xr-x 1 pi pi    433 Jun 15  2014 morris.css

pi$ ls -l static/js/
total 512
-rw-r--r-- 1 pi pi  37045 Feb 11 16:38 bootstrap.min.js
-rw-r--r-- 1 pi pi  86709 Feb 11 16:38 jquery-3.1.1.min.js
-rw-r--r-- 1 pi pi 253669 Sep 14 18:34 jquery-ui.min.js
-rw-r--r-- 1 pi pi   5552 Feb 12 15:34 lab5.js
-rwxr-xr-x 1 pi pi  35652 Jun 15  2014 morris.min.js
-rw-r--r-- 1 pi pi  93251 Feb  9 20:36 raphael.min.js
```

### Step C2: New Dashboard!
As we try to pack more sensor data types and displays into our small display, we
need to find a better UI element to display. Enter the "Tabbed" display! 
Fortunately we don't have to work hard at all to have a tab based panel display.
The above libraries provide us with a simple way to have this multi-tab interface.

![Dashboard with jQuery-UI](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/Dashboard-jQuery-UI.png)

Rather than detail out the Web design and coding steps (since this isn't a Web
design class) let's focus on just using this capability and doing just the small
amount of coding required to integrate what we coded in class already for tablular
data display.

### Step C3: GIT PULL and Let's GO!
We want to keep pace with next labs and there's quite a bit of UI tweaking required
to get the display just the way we want it for this stage.  Therefore just do a
git pull and you'll be 100% ready to move on to the homework of integrating the
pressure data chart.

[PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/PartD.md) Add MorrisJS Charting Capability for the Pressure

[LAB5 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/setup.md)
[LAB5 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/setup.md)

## Part D - Add MorrisJS Charting Capability for the Pressure
**Synopsis:** In parts A-C we built up quite a capability from capturing our sensor
data in Python, converting the sensor data object to JavaScript and then a fairly
major overhaul of our webapp UI to get into position for adding multiple sensor
data types.  This is just the beginning of the typical process of creating a 
sensor dashboard.  For this last part we'll just detail what we had to do to 
successfully integrate the MorrisJS temperature chart and we'll leave it as the
Lab5 homework exercise to do the same for the pressure chart.

## Objectives
* Describe how to Integrate MorrisJS Charting Capability
* JavaScript code modifications and new functions to handle temperature charting
* Description of how to integrate pressure

### Step D1: MorrisJS Charting Capability
Morris.js provides a very simple way to get started with clean and useful chart
integration into our web displays including hover data point viewing.  Visit the 
following website for Morris to study the APIs.
[MorrisJS](http://morrisjs.github.io/morris.js/)

We will integrate the simple line chart based on their starter example.  First we 
will need to put an HTML element that will place the chart.  We will locate this 
in one of the jQuery Tabbed panel elements as follows in the ```<div id="tabs-temp">```
element:
```html
    <div id="tabs">
      <ul>
        <li><a href="#tabs-table-data">Table Data</a></li>
        <li><a href="#tabs-temp">Temperature Chart</a></li>
        <li><a href="#tabs-press">Pressure Chart</a></li>
      </ul>
      
      <div id="tabs-table-data">
        <table class="table table-hover table-striped">
            ... (table data)
        </table>
      </div>
      
      <div id="tabs-temp">
        <div id="mytempchart" style="height: 70%; width: 95%;"></div>
      </div>
      
      <div id="tabs-press">
        ...
      </div>
    </div>

```
The inclusion of MorrisJS charting will reference the css id ```mytempchart``` as
a means to render the chart.

### Step D2: JavaScript functions for Temperature Charting
We added Morris charting capability to ```lab5.js``` as follows.  First we need
to create an object to refer to the temperature chart. This contains a data
array that will hold a series of (time, y-value) to be plotted.  Once we've
instantiated the ```graph``` object, we can add data to it as shown in the next
code snippet.
```javascript
var graph = new Morris.Line({
  element: 'mytempchart',
  data: [],
  xkey: 'time',
  ykeys: ['value'],
  labels: ['Value']
});
```

In this simple dashboard, we have hardcoded 5 data points that stream update.  
That is, when we pass data to this chart it is the last 5 data points captured
on a moving time window of 5 data points.
```javascript
function update_temp_chart(data) {
  var chart_data = [
    { time: data[0]['time'], value: data[0]['temp'] },
    { time: data[1]['time'], value: data[1]['temp'] },
    { time: data[2]['time'], value: data[2]['temp'] },
    { time: data[3]['time'], value: data[3]['temp'] },
    { time: data[4]['time'], value: data[4]['temp'] }
  ];
  graph.setData(chart_data);
}
```

Finally, we'll show the ```updateSensors``` function which calls this function to
update the display.  Note that only whene the tab is selected will the chart be
in view on the web page.

```javascript
updateSensors = (function (d) {
  var t_c = d['temperature'].reading
  var p_mbar = d['pressure'].reading
  var t_f = (t_c * 9) / 5.0 + 32.0;
  var p_inHg = p_mbar * MBAR_TO_inHG;

  var timedata = getDateNow();
  var t =  t_c.toFixed(1) + ' | ' + t_f.toFixed(1);
  var p =  p_mbar.toFixed(1) + ' | ' + p_inHg.toFixed(2);

  var obj = {};
  obj['date'] = timedata.date;
  obj['time'] = timedata.date;
  obj['temp'] = t;
  obj['press'] = p;
  data.push(obj);

  console.log(timedata);
  if (data.length > 5) {
    data.shift();
    clearTable();
    updateTable(data);
    update_temp_chart(data);
  }
});
```
The result of all these modifications is that we now have a temperature chart in
our dashbard on the temperature tab panel.
![TemperatureDashboardChart](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/DashboardTemperature.png)

### Step D3: Homework => Create MorrisJS Pressure Chart
For this week's homework you will want to make changes to the index.html (tab 
panel structure) and the JavaScript to incorporate a 5 datapoint pressure chart
much the same way the temperature chart was created.  

Good luck!  (The solution will be posted below after the assignment is completed)

```
Solution coming soon!
```

[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/PartC.md) Display Time, Temp and Pressure in a Bootstrap Table Structure

[LAB5 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/setup.md)
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up Lab5

### Objectives
For this lab we will continue building on our IoT suite by creating a web app
for our BMP280 sensor device.  We will maintain our LED/Switch configuration for
now and optimize the user interface dashboard for panels of each sensing element. 
We will particularly focus on how to create data objects in one language (Python) 
and transport them (via SSE) to another language (JavaScript).  This is how our
Thing will continue to get smarter in talking to the Internet.

The various steps of this lab are summarized as:
* [PART A](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/PartA.md) Create a Sensor Data Object
* [PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/PartB.md) Send the Sensor Data Object to the Webapp
* [PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/PartC.md) Display Time, Temp and Pressure in a Bootstrap Table Structure
* [PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab5/PartD.md) Add MorrisJS Charting Capability for the Pressure

[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)
[LAB6 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/setup.md)

## Part A - Test SenseHat Hardware
**Synopsis:** We need to initially test and ensure that the SenseHat hardware is
functional and driver is loaded.

## Objectives
* Fasten [SenseHat](https://www.raspberrypi.org/products/sense-hat/) to RPi3 Platform
* Browse to the [SenseHat API](http://pythonhosted.org/sense-hat/api/)
* Startup and manually send a message and read some temperature data

### Step A1: Install SenseHat Library
```sh
pi$ sudo apt-get update
pi$ sudo apt-get install sense-hat
pi$ sudo reboot
```

### Step A2: Hello SenseHat
```sh
pi$ python
>>> from sense_hat import SenseHat
>>> sense = SenseHat()
>>> sense.show_message("Hello SenseHat World!")
```
This should scroll a message across the SenseHat LED Matrix Display.


### Step A3: Verify some Sensor Data
```sh
pi$ python
>>> from sense_hat import SenseHat
>>> sense = SenseHat()
>>> temp = sense.get_temperature()
>>> print("Temperature: %s C" % temp)
Temperature: 31.2470054626 C
>>> <ctrl-D>
```

### Step A4: Check the I2C Bus Address Map
```sh
pi$ sudo i2cdetect -y 1
0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- 1c -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- UU -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- 5c -- -- 5f
60: -- -- -- -- -- -- -- -- -- -- 6a -- -- -- -- --
70: -- -- -- -- -- -- -- --
```
You are now ready to use SenseHat!

[PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/PartB.md) Import jQuery UI Framework for Lab6

[LAB6 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/setup.md)
[LAB6 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/setup.md)

## Part C - Import jQuery UI Framework for Lab6
**Synopsis:** We will simply perform a git pull on iot110-student to pull all of
the relevant JS libraries and the HTML/CSS code needed for this webapp.

## Objectives
* Check to ensure static folder is available
* static/js
* static/css


### Step C1: check the JS folder
```sh
pi$ cd ~/Documents/GIT_REPOS/iot110

pi$ ls -l static/js
total 508
-rw-r--r-- 1 pi pi  37045 Feb 14 06:36 bootstrap.min.js
-rw-r--r-- 1 pi pi  86709 Feb 14 06:36 jquery-3.1.1.min.js
-rw-r--r-- 1 pi pi 253669 Feb 14 06:36 jquery-ui.min.js
-rw-r--r-- 1 pi pi   3250 Feb 16 08:23 lab6.js
-rw-r--r-- 1 pi pi  35652 Feb 14 06:36 morris.min.js
-rw-r--r-- 1 pi pi  93251 Feb 14 06:36 raphael.min.js
```

### Step C2: check the CSS folder
```sh
pi$ ls -l static/css
total 176
-rw-r--r-- 1 pi pi 121200 Feb 14 06:37 bootstrap.min.css
-rw-r--r-- 1 pi pi  32076 Feb 14 06:37 jquery-ui.min.css
-rw-r--r-- 1 pi pi  13849 Feb 14 06:37 jquery-ui.theme.min.css
-rw-r--r-- 1 pi pi    986 Feb 14 06:37 lab6.css
-rw-r--r-- 1 pi pi    433 Feb 14 06:37 morris.css

```

You are now ready to use develop the SenseHat API and Main WebApp Code

[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/PartC.md) SenseHat Driver and Main WebApp Python Code

[LAB6 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/setup.md)
[LAB6 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/setup.md)

## Part C - SenseHat Driver and Main WebApp Python code
**Synopsis:** Now we are developing an interface similar to our other sensor
labs.

## Objectives
* Create ```sense.py``` and add various sensor APIs
* UnitTest ```sense.py``` (via its main function)
* Modify ```main.py```

### Step C1: SenseHat Driver ```sense.py```
```python
#!/usr/bin/python
from sense_hat import SenseHat

class PiSenseHat(object):
    """Raspberry Pi 'IoT Sense Hat API Driver Class'."""

    # Constructor
    def __init__(self):
        self.sense = SenseHat()
        # enable all IMU functions
        self.sense.set_imu_config(True, True, True)

    ... (more to come...)    
```

### Step C2: Add an API for each Sensor
```python
# Pressure
def getPressure(self):
    return self.sense.get_pressure()

# Temperature
def getTemperature(self):
    return self.sense.get_temperature()

# Humidity
def getHumidity(self):
    return self.sense.get_humidity()

def getHumidityTemperature(self):
    return self.sense.get_temperature_from_humidity()

def getPressureTemperature(self):
    return self.sense.get_temperature_from_pressure()

def getOrientationRadians(self):
    return self.sense.get_orientation_radians()

def getOrientationDegrees(self):
    return self.sense.get_orientation_degrees()

# degrees from North
def getCompass(self):
    return self.sense.get_compass()

def getAccelerometer(self):
    return self.sense.get_accelerometer_raw()

def getEnvironmental(self):
    sensors = {'name' : 'sense-hat', 'environmental':{}}
    return sensors

def getJoystick(self):
    sensors = {'name' : 'sense-hat', 'joystick':{}}
    return sensors

def getInertial(self):
    sensors = {'name' : 'sense-hat', 'inertial':{}}
```


### Step C3: Add an API for each Sensor
```python
def getAllSensors(self):
    sensors = {'name' : 'sense-hat', 'environmental':{}, 'inertial':{}, 'joystick':{}}
    sensors['environmental']['pressure'] = { 'value':self.sense.get_pressure(), 'unit':'mbar'}
    sensors['environmental']['temperature'] = { 'value':self.sense.get_temperature(), 'unit':'C'}
    sensors['environmental']['humidity'] = { 'value':self.sense.get_humidity(), 'unit': '%RH'}
    accel = self.sense.get_accelerometer_raw()
    sensors['inertial']['accelerometer'] = { 'x':accel['x'], 'y':accel['y'], 'z': accel['z'], 'unit':'g'}
    orientation = self.sense.get_orientation_degrees()
    sensors['inertial']['orientation'] = { 'compass':self.sense.get_compass(), 'pitch':orientation['pitch'], 'roll':orientation['roll'], 'yaw': orientation['yaw'], 'unit':'degrees'}
    return sensors
```

### Step C3: main to test from CLI
```python
def main():

    # create an instance of my pi sense-hat sensor object
    pi_sense_hat = PiSenseHat()

    # Read Parameters.
    p = pi_sense_hat.getPressure()
    t_c = pi_sense_hat.getTemperature()
    h = pi_sense_hat.getHumidity()
    ht = pi_sense_hat.getHumidityTemperature()
    hp = pi_sense_hat.getPressureTemperature()
    orientation = pi_sense_hat.getOrientationDegrees()
    accel = pi_sense_hat.getAccelerometer()
    d = pi_sense_hat.getCompass()

    print("================ Discrete Sensor Values ==================")
    print "      Pressure :", p
    print "   Temperature :", t_c
    print "      Humidity :", h
    print "  HumidityTemp :", ht
    print "  PressureTemp :", hp
    print "       Compass :", d
    print("  p: {pitch}, r: {roll}, y: {yaw}".format(**orientation))
    print("  x: {x}, y: {y}, z: {z}".format(**accel))
    print("==========================================================\n")

    print("================== Dictionary Object =====================")
    print(pi_sense_hat.getAllSensors())
    print("==========================================================\n")

if __name__=="__main__":
   main()
```

### Step C4: the ```Flask main.py```
```python
#!/usr/bin/python
import time
from sense import PiSenseHat
from flask import *

# create Pi SenseHat Object
pi_sense_hat = PiSenseHat()

# ============================== Functions ====================================
def get_sensor_values():
    return pi_sense_hat.getAllSensors()

# ============================== API Routes ===================================
app = Flask(__name__)

@app.route("/")
def index():
    return render_template('index.html')

# =========================== Endpoint: /myData ===============================
# read the sensor values by GET method from curl for example
# curl http://iot8e3c:5000/myData
# -----------------------------------------------------------------------------
@app.route('/myData')
def myData():
    def get_values():
        while True:
            # return the yield results on each loop, but never exits while loop
            data_obj = get_sensor_values()
            yield('data: {0}\n\n'.format(data_obj))
            time.sleep(1.0)
    return Response(get_values(), mimetype='text/event-stream')
# ============================== API Routes ===================================

if __name__ == "__main__":
    app.run(host='0.0.0.0', debug=True, threaded=True)
```

OK, onward to our webapp!

[PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/PartD.md) Build Sensor UI Components

[LAB6 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/setup.md)
[LAB6 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/setup.md)

## Part D - Finally!  The Web appeared
**Synopsis:** Finally we will tie all of this together and have all of our sensor
values both plotable and graphed on our Morris JS Chart.

## Objectives
* Test that we can receive data from the Driver and Main
* Add code to display Environmental Data in a Table in real-time
* Add code to display Inertial Data in a Table in real-time
* Add code to display Environmental Data in a in a Chart Form
* Add code to display Inertial Data in a Chart Form

### Step D1: Let's test the incoming data
```Javascript
$(document).ready(function() {

  // the key event receiver function
  iotSource.onmessage = function(e) {
    // must convert all single quoted data with double quote format
    var double_quote_formatted_data = e.data.replace(/'/g, '"');
    // now we can parse into JSON
    parsed_json_data = JSON.parse(double_quote_formatted_data);
    console.log(parsed_json_data);
  }
    ...more to come
```    

### Step D2:

![Inertial  Table Data](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/InertialTable.png)

![Inertial Chart Data](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/InertialChart.png)

[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/PartC.md) SenseHat Driver and Main WebApp Python Code

[LAB6 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/setup.md)
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up Lab6

**Synopsis:** For this lab we will continue building on our IoT suite by creating a web app
for the SenseHat device.  We will build on the jQuery  dashboard user interface
we started in Lab5, but focus on the major functional sensor and actuator classes
of the SenseHat platform.  Using the same Server Sent Events and JavaScript
charting capability we established in Lab5, we will extend to the *Environmental*,
*Inertial* sensors and provision for a future UI around the *JoyStick* and *LED
Matrix* Display capability.

### Objectives
* Test to ensure SenseHat hardware is functional and Python Library is Loaded
* Import jQuery UI HTML/CSS *Tabbed Panel* Framework
* Build a ```sense.py``` Python Driver to Provide an API for the SenseHat
* Interface the main Flask webapp ```main.py``` to the SenseHat Driver
* Add JavaScript code to parse the SenseHat sensor data and render on Tab panels

The various steps of this lab are summarized as:
* [PART A](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/PartA.md) Test SenseHat Hardware
* [PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/PartB.md) Import jQuery UI Framework for Lab6
* [PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/PartC.md) SenseHat Driver and Main WebApp Python code
* [PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab6/PartD.md) Build Sensor UI Components

[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Additional Supplemental Information for Debug ##
If your SenseHat is experiencing specific errors, your RPi may be in need of an
update ... see below:
[Errors running SenseHat](https://www.reddit.com/r/raspberry_pi/comments/3yg0rz/sense_hat_and_jessie/)

May need to run
```
pi$ sudo rpi-update
 *** Downloading specific firmware revision (this will take a few minutes)
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
                                 ...
 *** Updating firmware
 *** Updating kernel modules
 *** depmod 4.4.48+
 *** depmod 4.4.48-v7+
 *** Updating VideoCore libraries
 *** Using HardFP libraries
 *** Updating SDK
 *** Running ldconfig
 *** Storing current firmware revision
 *** Deleting downloaded files
 *** Syncing changes to disk
 *** If no errors appeared, your firmware was successfully updated to 71c475563fd5aa4ade62c9a31dd25865ab7d4a7b
 *** A reboot is needed to activate the new firmware
```
[LAB7 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/setup.md)

## Part A - Check Starter Files, Sensors and PWM
**Synopsis:** In this part, we will re-test that the BMP280 sensor is still 
operating correctly and also run the pre-coded unit test for LED PWM control. 
Due to the amount of code needed to operate the stepper motor, the LED PWM 
driver and unit test are provided for this lab.

## Objectives
* Check to ensure all starter files are present in the lab
* Run the BMP280 temperature and pressure sensor unit test
* Run the LED PWM unit test

### Step A1: Check starter files
```sh

pi$ git pull (from iot110-student REPO, then copy to your working folder)

pi$ cd webapp
pi$ tree  .
.
 bmp280.py
 main.py
 pwm.py
 pwm_test.py
 static
  css
   bootstrap.min.css
   jquery-ui.min.css
   jquery-ui.theme.min.css
   lab7.css
   morris.css
  icon
   favicon.ico
  js
      bootstrap.min.js
      jquery-3.1.1.min.js
      jquery-ui.min.js
      lab7.js
      morris.min.js
      raphael.min.js
 stepper.py
 stepper_test.py
 templates
     index.html

```    

### Step A2: Run BMP280 Unit Test
```python
# =============================================================================
# main to test from CLI
def main():

    # create an instance of my pi bmp280 sensor object
    pi_bmp280 = PiBMP280()

    # Read the Sensor ID.
    (chip_id, chip_version) = pi_bmp280.readBMP280ID()
    print "    Chip ID :", chip_id
    print "    Version :", chip_version

    # Read the Sensor Temp/Pressure values.
    (temperature, pressure) = pi_bmp280.readBMP280All()
    print "Temperature :", temperature, "C"
    print "   Pressure :", pressure, "hPa"

if __name__=="__main__":
   main()
# =============================================================================

# -----------------------------------------------------------------------------
pi$ ./bmp280
    Chip ID : 88
    Version : 1
Temperature : 24.78 C
   Pressure : 1006.53054419 hPa
# -----------------------------------------------------------------------------
```    

### Step A3: Run LED PWM Unit Test
```python
# =============================================================================
#!/usr/bin/python

import time
from pwm import PiPwm

PWM0 = 0    # logical handle for RPi3 PWM0
PWM1 = 1    # logical handle for RPi3 PWM1
# create an instance of my pi thing.
pi_pwm = PiPwm()

# Create two counter breathing PWM LEDs
print('Connect RED LED to GPIO18, GREEN LED to GPIO13, DIR SW to GPIO25')

time.sleep(1.0)
print('Starting PWM0 at 5Hz with 75% duty cycle')
ch0 = pi_pwm.start_pwm(0, 5, 75)
# time.sleep(0.01)
print('Starting PWM1 at 3Hz with 10% duty cycle')
ch1 = pi_pwm.start_pwm(1, 5, 10)

time.sleep(10.0)
print('Stopping PWM0')
pi_pwm.stop_pwm(ch0)
time.sleep(3.0)
print('Stopping PWM1')
pi_pwm.stop_pwm(ch1)
# =============================================================================

(review the pwm.py driver in Atom)

$pi ./pwm_test.py
Connect RED LED to GPIO18, GREEN LED to GPIO13, DIR SW to GPIO25
Starting PWM0 at 5Hz with 75% duty cycle
Starting PWM1 at 3Hz with 10% duty cycle
Stopping PWM0
Stopping PWM1
```    

[PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/PartB.md) Develop stepper.py and unit test

[LAB7 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/setup.md)
[LAB7 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/setup.md)

## Part B - Develop Stepper Motor Driver and Unit Test
**Synopsis:** We will be controlling the stepper motor using the TB6612 driver 
chip.  This chip buffers the GPIO signals driving the AIN1/2, BIN1/2 and STBY
signals and turns them into 4 high current driver outputs.  All of the signals
are manually managed by bit banging the GPIOs (no automatic PWM timing).  The "PWM"
signals listed in the TB6612 datasheet are simply tied to +5V.

## Objectives
* Code the ```stepper.py``` Driver
* Code the ```stepper_test.py``` Unit Test
* Run the Stepper Unit Test and Check all wiring

### Step B1: The ```stepper.py``` Driver [import | constants | constructor]
```python
import RPi.GPIO as GPIO
import time

LED     = 23    # GPIO23 RUNNING STATUS LED
SW      = 25    # cobbler pin 22 (GPIO25)

AIN1    = 19    # GPIO19 TB6612 AIN1 Logic Input
AIN2    = 26    # GPIO26 TB6612 AIN2 Logic Input
BIN1    = 20    # GPIO20 TB6612 BIN1 Logic Input
BIN2    = 21    # GPIO21 TB6612 BIN2 Logic Input
STBY    = 16    # GPIO16 TB6612 Standby Input

# =============================================================================
# create a Stepper Motor Object
# -----------------------------------------------------------------------------
class PiStepper(object):
    """Raspberry Pi 'IoT GPIO Stepper Motor'."""

    def __init__(self, freq=10, steps=600):
        self.steps_per_rev = steps
        self.sec_per_step = 0.1
        self.steppingcounter = 0
        self.currentstep = 0
        self.speed = 0
        self.state = 0
        self.steps = 0
        self.direction = 0
        self.position = 0

        GPIO.setwarnings(False)
        GPIO.setmode(GPIO.BCM)          # BMC Pin numbering convention
        GPIO.setup(LED, GPIO.OUT)       # LED as output
        GPIO.setup(AIN1, GPIO.OUT)      # AIN1 as output
        GPIO.setup(AIN2, GPIO.OUT)      # AIN2 as output
        GPIO.setup(BIN1, GPIO.OUT)      # BIN1 as output
        GPIO.setup(BIN2, GPIO.OUT)      # BIN2 as output
        GPIO.setup(STBY, GPIO.OUT)      # Standby as output
        GPIO.output(AIN1,0)             # initialize AIN1 state to off
        GPIO.output(AIN2,0)             # initialize AIN2 state to off
        GPIO.output(BIN1,0)             # initialize BIN1 state to off
        GPIO.output(BIN2,0)             # initialize BIN2 state to off
        GPIO.output(STBY,0)             # initialize Standby state to off
        GPIO.setup(SW,  GPIO.IN, pull_up_down=GPIO.PUD_UP)
# -----------------------------------------------------------------------------

```    

### Step B2: Add Basic Interface Methods, Getters/Setters
```python
# -----------------------------------------------------------------------------
    def hello(self):
        print "Hello Stepper"

    def start(self):
        print "Starting Stepper Motor"
        GPIO.output(LED,1)      # turn on LED status
        GPIO.output(STBY,1)     # TB6612 Standby State TRUE
        self.state = 1

    def stop(self):
        print "Stopping Stepper Motor"
        GPIO.output(LED,0)      # turn off LED status
        GPIO.output(STBY,0)     # TB6612 Standby State FALSE
        self.state = 0

    def getState(self):
        return self.state

    # get motor position
    def getPosition(self):
        return self.position

    # set motor position
    def setPosition(self,position):
        self.position = position

    # set the speed parameters for stepper motor based on RPM
    def setSpeed(self, rpm):
        self.sec_per_step = 60.0 / (self.steps_per_rev * rpm)
        self.steppingcounter = 0
        self.speed = rpm

    def getSpeed(self):
        return self.speed
# -----------------------------------------------------------------------------
```

### Step B3: Add Stepper Coil Sequencing
```python

    # perform one step in sequence at a direction CW or CCW
    def oneStep(self, direction):
        # go to next 'step' and wrap around
        self.direction = direction
        coils = [0, 0, 0, 0]
        step2coils = [
        #    A2 B1 A1 B2
            [1, 0, 0, 0],
            [1, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 1, 1, 0],
            [0, 0, 1, 0],
            [0, 0, 1, 1],
            [0, 0, 0, 1],
            [1, 0, 0, 1] ]
        coils = step2coils[self.currentstep]
        # print '%d', self.currentstep, " : coils = AIN1:%d AIN2:%d BIN1:%d BIN2:%d" % (coils[2],coils[0],coils[1],coils[3])

        # post increment/decrement the modulo step counter depeneding on direction
        #   also update the stepper position (one tic per step)
        if(direction == 1):
            self.currentstep += 1
            self.position += 1
        else:
            self.currentstep -= 1
            self.position -= 1
        self.currentstep %= 8

        #print "coils state = " + str(coils)
        self.setPin(AIN2, coils[0])
        self.setPin(BIN1, coils[1])
        self.setPin(AIN1, coils[2])
        self.setPin(BIN2, coils[3])

    # set current pin in sequence
    def setPin(self, pin, value):
        GPIO.output(pin,value)

    # set motor direction
    def setDirection(self,direction):
        self.direction = direction

    # get motor direction
    def getDirection(self):
        return self.direction

    # set motor steps
    def setSteps(self,steps):
        self.steps = steps

    # get motor direction
    def getSteps(self):
        return self.steps

    # execute all steps
    def step(self, steps):
        s_per_s = self.sec_per_step

        for s in range(steps):
            self.oneStep(self.direction)
            time.sleep(s_per_s)

    # de-energize all coils
    def nullCoils(self):
        coils = [0, 0, 0, 0]
        self.setPin(AIN2, coils[0])
        self.setPin(BIN1, coils[1])
        self.setPin(AIN1, coils[2])
        self.setPin(BIN2, coils[3])

```

### Step B4: Add Stepper Unit Test
```python
#!/usr/bin/python
import time
from stepper import PiStepper

CW = 1
CCW  = 0

# Create a stepper motor controller object
pi_smc = PiStepper()
print('Motor Controller Initialized')

# set the initial RPM speed

pi_smc.start()
pi_smc.setSpeed(100)
print 'Finding Home Position...'
pi_smc.setDirection(CCW)
pi_smc.step(1200)
pi_smc.setPosition(0)

# loop through several CW and CCW steps
for rpm in range(100,200):
    pi_smc.setSpeed(rpm)
    print '\n-------> Speed: %d rpm <-------' % (rpm)

    print('Stepping CW')
    pi_smc.setDirection(CW)
    pi_smc.step(600)
    time.sleep(0.2)
    pi_smc.step(600)
    print 'Position: %d (steps)' % (pi_smc.getPosition())

    print('Change Dir')
    pi_smc.nullCoils()
    time.sleep(0.1)

    print('Stepping CCW')
    pi_smc.setDirection(CCW)
    pi_smc.step(600)
    time.sleep(0.2)
    pi_smc.step(600)
    print 'Position: %d (steps)' % (pi_smc.getPosition())
    print('Change Dir')
    pi_smc.nullCoils()
    time.sleep(0.1)

print('Stopping Motor')
pi_smc.stop()
```

[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/PartC.md) Modify main.py for stepper and PWM control code

[LAB7 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/setup.md)
[LAB7 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/setup.md)

## Part C - Modify our ```main.py``` to include stepper
**Synopsis:** We've added our driver code now we need to hook up our API so that 
the webapp can connect to it.

## Objectives
* Top of Main
* Environmental Sensor Gather Function
* API Routes for the Stepper
* API Routes for the PWM LED (to be done in class)

### Step C1: top of main.py
```python
#!/usr/bin/python
import time
import pprint
from stepper import PiStepper
from bmp280 import PiBMP280
from flask import *
app = Flask(__name__)

# Create a stepper motor controller object
pi_smc = PiStepper()

# create a pi bmp280 sensor object and data structure
env_sensor = {'name' : 'bmp280', 'addr' : 0x76, 'chip' : PiBMP280(0x76) , 'data' : {}}
```    

### Step C2: Environmental Sensors
```python
## function to read environmental parameters
def get_env_sensors():
    # Read the Sensor ID for 0x76 -> values into the ['data'] dictionary
    (chip_id, chip_version) = env_sensor['chip'].readBMP280ID()
    env_sensor['data']['chip_id'] = chip_id
    env_sensor['data']['chip_version'] = chip_version

    # Read the Sensor Temp/Pressure values into the ['data'] dictionary
    (temperature, pressure) = env_sensor['chip'].readBMP280All()
    env_sensor['data']['temperature'] = { 'reading': temperature, 'units' : 'C' }
    env_sensor['data']['pressure'] = { 'reading': pressure, 'units' : 'hPa' }
    return env_sensor['data']
```

### Step C3: API Route to kick off Webpage
```python
# ============================== API Routes ===================================
@app.route("/")
def index():
    return render_template('index.html')
    
```

### Step C4: API Routes for Stepper Motor
```python
# ============================= POST: /motor/<state> ============================
# control motor by POST methods from curl for example
# curl http://iot8e3c:5000/motor/0
# curl http://iot8e3c:5000/motor/1
# -----------------------------------------------------------------------------
@app.route("/motor/<int:motor_state>", methods=['GET'])
def motor(motor_state):
    if motor_state == 0:    # stop
        pi_smc.stop()
    elif motor_state == 1:      # start
        pi_smc.start()
    else:
        return ('Unknown Stepper Motor state!', 400)
    return ('', 204)


# ====================== GET: /motor_speed/<speed_rpm> ========================
# set the motor speed in RPM by GET method from curl. For example:
# curl http://iot8e3c:5000/motor_speed/60
# -----------------------------------------------------------------------------
@app.route("/motor_speed/<int:motor_speed>", methods=['GET'])
def set_motor_speed(motor_speed):
    pi_smc.setSpeed(motor_speed)
    return "Set Motor Speed : " + str(pi_smc.getSpeed()) + "\n"

# ===================== GET: /motor_direction/<direction> =====================
# set the motor direction (CW/CCW) by GET method from curl. For example:
# curl http://iot8e3c:5000/motor_direction/1
# -----------------------------------------------------------------------------
@app.route("/motor_zero", methods=['GET'])
def set_motor_zero():
    pi_smc.setPosition(0)
    return "Set Motor Position : " + str(pi_smc.getPosition()) + "\n"

# ===================== GET: /motor_direction/<direction> =====================
# set the motor direction (CW/CCW) by GET method from curl. For example:
# curl http://iot8e3c:5000/motor_direction/1
# -----------------------------------------------------------------------------
@app.route("/motor_direction/<string:direction>", methods=['GET'])
def set_motor_dir(direction):
    pi_smc.setDirection(direction)
    return "Set Motor Direction : " + str(pi_smc.getDirection()) + "\n"

# ===================== GET: /motor_steps/<steps> =====================
# set the motor steps (int) by HTTP GET method  CURL example:
# curl http://iot8e3c:5000/motor_steps/100
# -----------------------------------------------------------------------------
@app.route("/motor_steps/<int:steps>", methods=['GET'])
def set_motor_steps(steps):
    pi_smc.setSteps(steps)
    return "Set Motor Steps : " + str(pi_smc.getSteps()) + "\n"

# ====================== GET: /motor_position/<position> ======================
# set the motor position by HTTP GET method. CURL example:
# curl http://iot8e3c:5000/motor_position/1
# -----------------------------------------------------------------------------
@app.route("/motor_position/<int:position>", methods=['GET'])
def set_motor_pos(position):
    pi_smc.setDirection(direction)
    return "Set Motor Direction : " + str(pi_smc.getDirection()) + "\n"


# ======================= POST: /motor_multistep/<dir> =========================
# set the motor multistep by POST method from curl. For example:
# curl --data 'steps=10&direction=CW' http://iot8e3c:5000/motor_multistep
# -----------------------------------------------------------------------------
@app.route("/motor_multistep", methods=['POST'])
def postMotorMultistep():
    ctrl_data = request.data
    print "Motor Control Data:" + ctrl_data
    direction = str(request.form['direction'])
    if (direction == 'CW'):
        pi_smc.setDirection(1)
    elif (direction == 'CCW'):      # start
        pi_smc.setDirection(0)
    else:
        return ('Unknown Stepper Motor Direction!', 400)

    steps = str(request.form['steps'])
    pi_smc.step(int(steps))

    return "Motor Multisteps Steps:" + steps + " Direction:"+ direction + "\n"
```

### Step C5: API Route for Server Sent Events + app_main
```python
# =========================== Endpoint: /myData ===============================
# read the sensor values by GET method from curl for example
# curl http://iot8e3c:5000/myData
# -----------------------------------------------------------------------------
@app.route('/myData')
def myData():
    def get_values():
        while True:
            # return the yield results on each loop, but never exits while loop
            data_obj = {'environmental' : get_env_sensors(),
                        'motor' : { 'position':str(pi_smc.getPosition()),
                                    'state':str(pi_smc.getState()) }
            }

            yield('data: {0}\n\n'.format(data_obj))
            time.sleep(2.0)
    return Response(get_values(), mimetype='text/event-stream')
# ============================== API Routes ===================================

if __name__ == "__main__":
    app.run(host='0.0.0.0', debug=True, threaded=True)
# =============================================================================
```

[PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/PartD.md) Refactor index.html and add Javascript Tabs

[LAB7 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/setup.md)
[LAB7 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/setup.md)

## Part D - Add JavaScript for Stepper/PWM Control and Temp/Pressure Sensor
**Synopsis:** We have all of our low level tools integrated and tested.  Now it's
time to modify our webpage (```index.html```) and the associated (```lab7.js```) 
JavaScript that provides all the interface and dynamic behavior.

## Objectives
* Add additional Tabs and Concent to ```index.html```
* Add Stepper Motor functionality to lab7.js
* Add PWM LED dimmer control to lab7.js

### Step D1: Webapp head section
Ensure all libraries are correctly ordered in ```<head>``` section.
```html
<head>
  <meta charset="utf-8">
  <title>UW IoT Lab7</title>

  <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='css/morris.css') }}">
  <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='css/jquery-ui.min.css') }}">
  <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='css/bootstrap.min.css') }}">
  <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='css/lab7.css') }}">
  <link rel="shortcut icon" type="image/x-icon" href="{{ url_for('static',filename='icon/favicon.ico') }}">

  <script src="{{ url_for('static',filename='js/jquery-3.1.1.min.js') }}"></script>
  <script src="{{ url_for('static',filename='js/bootstrap.min.js') }}"></script>
  <script src="{{ url_for('static',filename='js/raphael.min.js') }}"></script>
  <script src="{{ url_for('static',filename='js/morris.min.js') }}"></script>
  <script src="{{ url_for('static',filename='js/jquery-ui.min.js') }}"></script>
  <script src="{{ url_for('static',filename='js/lab7.js') }}"></script>

</head>
```    

### Step D2: Tabs List Items
```html
                <li><a href="#tabs-environmental-data">EnvironTable</a></li>
                <li><a href="#tabs-stepper">STEPPER</a></li>
                <li><a href="#tabs-ledpwm">PWM LEDS</a></li>
```

### Step D3: Table for Temperature and Pressure
```html
                <table class="table table-hover table-striped">
                  <tr class=param-header>
                    <th>Time (PST)</th>
                    <th>Temperature (&degC)</th>
                    <th>Pressure (mbar)</th>
                  </tr>
                  <tr class=env-param-row>
                  </tr>
                  <tr class=env-param-row>
                  </tr>
                  <tr class=env-param-row>
                  </tr>
                  <tr class=env-param-row>
                  </tr>
                </table>
```

### Step D4: Table for Stepper Controls
```html
                <table>
                  <tr>
                    <td>
                      <!-- <div class="container well"> -->
                        <table class="table">
                          <tr>
                            <td><h6>Motor Status  <span id='motor_state' class="label label-default">&#8635</span></h6></td>
                          </tr>
                          <tr>
                            <td><h6>Motor Position(steps)  <span id="motor_position" class="label label-default">100</span></h6></td>
                          </tr>
                        </table>
                      <!-- </div> -->
                    </td>
                    <td>
                      <table class="table">
                        <tr>
                          <td>New Motor Speed(rpm):</td>
                          <td><input id='motor_speed' type="number" min="0" max="250" name="rpm" value=100></td>
                        </tr>
                        <tr>
                          <td>Number of Steps:</td>
                          <td><input id='motor_steps' type="number" min="0" max="600" name="steps" value=100></td>
                        </tr>
                        <tr>
                          <td>Motor Direction:</td>
                          <td><select id='motor_direction' type="text" name="direction" value="CW">
                                <option value="CW">Clockwise</option>
                                <option value="CCW">Counter Clockwise</option>
                              </select>
                          </td>
                        </tr>
                      </table>
                    </td>
                  </tr>
                </table>
```

### Step D5: Buttons for Stepper Commands
```html
                <div id="stepper_buttons" class="container well">
                  <button type='button' class="btn btn-default" id='motor_start'>START</button>
                  <button type='button' class="btn btn-default" id='motor_stop'>STOP</button>
                  <button type='button' class="btn btn-default" id='motor_zero'>POS ZERO</button>
                  <button type='button' class="btn btn-success" id='motor_multistep'>MULTI-STEP</button>
                </div>
```

### Step D6: Table for PWM LED Sliders
```html
                <table>
                  <tr>
                    <td class="slider-col">
                      <p>
                        <h4>RED LED</h4>
                        DUTY CYCLE (%) <input type="text" id="pwm1" readonly>
                      </p>
                      <div id="slider1"></div>
                    </td>
                    <td class="slider-col">
                      <p>
                        <h4>GREEN LED</h4>
                        DUTY CYCLE (%) <input type="text" id="pwm2" readonly>
                      </p>
                      <div id="slider2"></div>
                    </td>
                  </tr>
                </table>
```

### Step D7: Code for RED LED Slider
```javascript
  $( "#slider1" ).slider({
    orientation: "vertical",
    range: "min",
    min: 0,
    max: 100,
    value: 50,
    animate: true,
    slide: function( event, ui ) {
      $( "#pwm1" ).val( ui.value );
      console.log("red led duty cycle(%):",ui.value);
    }
  });
  
```

### Step D8: Code for GREEN LED Slider
```javascript
  $( "#slider2" ).slider({
    orientation: "vertical",
    range: "min",
    min: 0,
    max: 100,
    value: 50,
    animate: true,
    slide: function( event, ui ) {
      $( "#pwm2" ).val( ui.value );
      console.log("grn led duty cycle(%):",ui.value);
    }
  });
```

### Step D9: Code for Environmental Sensor Tables
```javascript
  // ============================== ENV TABLE =================================
  updateEnvironmentalTableData = (function (d) {
    var env = d;
    var timedata = getDateNow();
    env['date'] = timedata.date;
    env['time'] = timedata.time;

    env_table_data.push(env);
    if (env_table_data.length > 4) {
      env_table_data.shift();
      clearEnvTables();
      updateEnvironmentalTable(env_table_data);
    }
  });

  function updateEnvironmentalTable(data) {
    $('tr.env-param-row').each(function(i) {
      var tm = '<td>' + data[i].date + '</td>';
      var t = '<td>' + data[i]['environmental']['temperature'].reading.toFixed(2) + '</td>';
      var p = '<td>' + data[i]['environmental']['pressure'].reading.toFixed(2) + '</td>';
      $(this).append(tm);
      $(this).append(t);
      $(this).append(p);
    });
  }
  function clearEnvTables() {
    $('tr.env-param-row').each(function(i) {
      $(this).empty();
    });
  }
  // ============================== ENV TABLE =================================
```

### Step D10: Code for Stepper Motor Control
```python
  // ============================ STEPPER MOTOR ===============================
  // Buttons
  $('#motor_start').click(function() {
    console.log('Start Motor Up!');
    $.get('/motor/1');
  });
  $('#motor_stop').click(function() {
    console.log('Stop Motor');
    $.get('/motor/0');
  });
  $('#motor_zero').click(function() {
    console.log('Zero Motor Position');
    $.get('/motor_zero');
  });
  $('#motor_multistep').click(function() {
    var params = 'steps='+$('#motor_steps').val()+"&direction="+$('#motor_direction').val();
    console.log('Multistep with params:' + params);
    $.post('/motor_multistep', params, function(data, status){
                console.log("Data: " + data + "\nStatus: " + status);
            });
  });

  // Text Fields
  $('#motor_speed').change(function() {
    console.log('Changed motor speed to ' + $('#motor_speed').val());
    $.get('/motor_speed/'+$('#motor_speed').val());
  });
  $('#motor_position').change(function() {
    console.log('Changed motor position to ' + $('#motor_position').val());
    $.get('/motor_position/'+$('#motor_position').val());
  });

  $('#motor_steps').change(function() {
    console.log('Changed motor steps to ' + $('#motor_steps').val());
    $.get('/motor_steps/'+$('#motor_steps').val());
  });

  $('#motor_direction').change(function() {
    console.log('Changed motor steps to ' + $('#motor_direction').val());
    $.get('/motor_direction/'+$('#motor_direction').val());
  });

  // ============================ STEPPER MOTOR ===============================
  function updateStepperMotor(data) {
    $('#motor_position').text(data['motor']['position']);
    if (data['motor']['state'] === '1') {
      $('#motor_state').toggleClass('label-default', false);
      $('#motor_state').toggleClass('label-success', true);
    } else if (data['motor']['state'] === '0') {
      $('#motor_state').toggleClass('label-default', true);
      $('#motor_state').toggleClass('label-success', false);
    }
  }
  // ============================ STEPPER MOTOR ===============================
```

[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/PartC.md) Modify main.py for stepper and PWM control code

[LAB7 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/setup.md)
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up Lab7

**Synopsis:** For this lab we will continue building on our IoT suite by creating
a web app for ACTUATORS.  For our Lab ACTUATORS we will be using 2 LEDs with a
dimming function created by pulse width modulation (PWM) and an automotive
instrument analog indicator using a precision stepper motor and the TB6612 Driver module.

### Objectives
* Test to ensure BMP280 sensor and driver are still working correctly (no code change)
* Test to ensure PWM LEDs and driver are working correctly (driver and unit test provided)
* Build a driver ```stepper.py``` for the motor and test (unit test provided)
* Interface the main Flask webapp ```main.py``` to the stepper and PWM drivers
* Add new HTML code for the PWM slider controls and stepper motor control.
* Add JavaScript code to add actuator control and status as well as sensing.

The various steps of this lab are summarized as:
* [PART A](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/PartA.md) Test BMP280 and PWM LEDs
* [PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/PartB.md) Develop stepper.py and unit test
* [PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/PartC.md) Modify main.py for stepper and PWM control code
* [PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab7/PartD.md) Refactor ```index.html``` and add Javascript Tabs

[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)
[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/setup.md)

## Part A - Install MQTT
**Synopsis:** In this part, we will install and test MQTT.

## Objectives
* apt-get MQTT libraries
* Install MQTT.fx on development host
* Configure and establish user and password

### Step A1: Install Libraries
```sh
sudo apt-get install mosquitto mosquitto-clients python-mosquitto
sudo pip install paho-mqtt

```    

### Step A2: Configure Mosquitto  (/etc/mosquitto/conf.d/mosquitto.conf)
```
pi$ sudo vim /etc/mosquitto/conf.d/mosquitto.conf

# Config file for mosquitto
#
# See mosquitto.conf(5) for more information.

# user mosquitto
# max_queued_messages 200
# message_size_limit 0
# allow_zero_length_clientid true
# allow_duplicate_messages false

listener 1883
# autosave_interval 900
# autosave_on_changes false
# persistence true
# persistence_file mosquitto.db
allow_anonymous false
password_file /etc/mosquitto/passwd
```    
### Step A3: Setup Username ("pi") and Password ("raspberry")
```sh
pi$ sudo mosquitto_passwd -c /etc/mosquitto/passwd pi
Password: ********* (<= "raspberry")
Reenter password: ********* (<= "raspberry")
```  

### Step A4: Start (Restart) the Mosquitto Daemon
```sh
pi$ sudo systemctl restart mosquitto
pi$ sudo reboot
pi$ mosquitto &
```

### Step A5: Subscribe to Topic "iot/test"
```sh
pi$ mosquitto_sub -d -u pi -P raspberry -t iot/test

```

### Step A6: Publish Hello String to Topic "iot/test"
```sh
pi$ mosquitto_pub -d -u pi -P raspberry -t iot/test -m "Hello MQTT!"

```

[PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/PartB.md)  Install MQTT Client Tool MQTT.fx

[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/setup.md)
[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/setup.md)

## Part B - Install MQTT Client Tool MQTT.fx
**Synopsis:** In this part, we will install and test the MQTT.fx client test tool.
This tool is quite useful in troubleshooting connections to the MQTT broker and
is able to explore the operation of publishing and subscribing to "topics".

## Objectives
* Download an [MQTT Test Client](http://www.jensd.de/apps/mqttfx/)
* Install and Configure MQTT.fx on development host
* Connect to our Mosquitto Broker (Server)

### Step B1: Install and Configure MQTT.fx
The following show installation on MacOSX, but a similar install and configuration
should apply to whatever is the target host development platform being used
for development in this class.
![MQTT Connection](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/MQTTfx_Connect.png)

### Step B2: Subscribe to some topics
![Subscribe-Redirect](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/SubscribeRedirect.png)

### Step B3: Publish to some topics
![First Publish](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/MQTT_FirstPub.png)

### Step B4: Observe Subscribed Topics
![Subscribed Topics](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/SubscribeHello.png)


[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/PartC.md) Create MQTT Python Test Code

[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/setup.md)
[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/setup.md)

## Part C - Create MQTT Python Test Code
**Synopsis:** In this part, we will code a number client entities to simulate
sensors, test real sensors from the SenseHat, create a MQTT listener that also
redirects payloads and sets up the framework that will be used for eventually
connecting to the Azure IoT Suite cloud platfrom.

## Objectives
* apt-get MQTT libraries
* Install MQTT.fx on development host
* Configure and establish user and password

### Step C1: Create an MQTT Listener
As usual, we will need to import a few tools.  We will need som
```python
#!/usr/bin/python
import time
import paho.mqtt.client as paho
import json
import ast

localBroker = "iot8e3c"     # Local MQTT broker
localPort   = 1883          # Local MQTT port
localUser   = "pi"          # Local MQTT user
localPass = "raspberry"     # Local MQTT password
localTopic = "iot/sensor"   # Local MQTT topic to monitor
cloudTopic = "iot/azure"    # publish to simulated Azure topic 
localTimeOut = 120          # Local MQTT session timeout

```    

### Step C2: Event Callback for On Connect
```python
# The callback for when a CONNACK message is received from the broker.
def on_connect(client, userdata, flags, rc):
    print("CONNACK received with code %d." % (rc))
    mqttc.subscribe(localTopic, 0)
```

### Step C3: Event Callback for On Message
```python
def on_message(mosq, obj, msg):
    global message
    print("Topic Rx:" + msg.topic + " QoS:" + str(msg.qos) + "\n")
    clean_json = ast.literal_eval(msg.payload)
    print ("Payload: ")
    # import pdb; pdb.set_trace()
    print json.dumps(clean_json , indent=4, sort_keys=True)
    # message = msg.payload
    # This is where we will develop client connect to  Azure IoT Suite
    mqttc.publish(cloudTopic,msg.payload, 1);
```
### Step C4: MQTT Listener startup Main
```python
print('Establish MQTT Broker Connection')
# Setup to listen on topic`
mqttc = paho.Client()
mqttc.on_connect = on_connect
mqttc.on_message = on_message
mqttc.connect(localBroker, localPort, localTimeOut)
print('MQTT Listener Loop <ctl-C> to break...')
mqttc.loop_forever()
```

### Step C5: Create an MQTT Test Client (part 1)
```python
#!/usr/bin/python
import time
import socket
import paho.mqtt.client as paho
from sense import PiSenseHat

myHostname = 'iot8e3c'

localBroker = "iot8e3c"		# Local MQTT broker
localPort   = 1883			# Local MQTT port
localUser   = "pi"			# Local MQTT user
localPass = "raspberry"		# Local MQTT password
localTopic = "iot/sensor"	# Local MQTT topic to monitor
localTimeOut = 120			# Local MQTT session timeout

# The callback for when a CONNACK message is received from the broker.
def on_connect(client, userdata, flags, rc):
    print("CONNACK received with code %d." % (rc))

# The callback for when a PUBLISH message is received from the broker.
def on_message(client, userdata, msg):
    print (string.split(msg.payload))

# display one row of blue LEDs (just for fun)
def displayLine(row):
    blue = (0, 0, 255)
    for i in range(0,8):
        x = i % 8
        y = (i / 8) + row
        # print("set pixel x:%d y:%d" % (x,y))
        pi_sense.set_pixel(x,y,blue)
        time.sleep(0.02)

```
### Step C6: Create an MQTT Test Client (part 2)
```python
# Create a sense-hat object
pi_sense = PiSenseHat()
print('PI SenseHat Object Created')

# Get hostname
## Get my machine hostname
# import pdb; pdb.set_trace()
if socket.gethostname().find('.') >= 0:
    hostname=socket.gethostname()
else:
    hostname=socket.gethostbyaddr(socket.gethostname())[0]

# Setup to Publish Sensor Data
mqttc = paho.Client()
mqttc.on_connect = on_connect
mqttc.on_message = on_message
mqttc.connect(localBroker, localPort, localTimeOut)

# initialize message dictionary
msg = {'topic':localTopic, 'payload':"", 'qos':0, 'retain':False }

pi_sense.clear_display()
# loop
print('Getting Sensor Data')
for i in range(1,9):
    print("SensorSet[%d]" % (i))
    displayLine(i-1)
    sensors = pi_sense.getAllSensors()

    sensors['host'] = hostname
    msg['payload'] = str(sensors)
    print("msg["+str(i)+"]:"+msg['payload'])

#   publish(topic, payload=None, qos=0, retain=False)
    mqttc.publish('iot/test', msg['payload'], 1)
    time.sleep(2.0)

print('End of MQTT Messages')
quit()
```

### Step C6: Create an MQTT Test Client (part 2)
```python

```

### Step C8: Modify our WebApp main.py setup
First, copy all of the code from Lab6 into Lab8.  Then make the following minor
changes to your ```main.py```.  Later, we will change the ```localBroker``` variable
to point to whatever platform is hosting Mosquitto the MQTT broker.
```python
# MQTT Configuration for local network
localBroker = "iot8e3c"		# Local MQTT broker
localPort   = 1883			# Local MQTT port
localUser   = "pi"			# Local MQTT user
localPass = "raspberry"		# Local MQTT password
localTopic = "iot/sensor"	# Local MQTT topic to monitor
localTimeOut = 120			# Local MQTT session timeout

# Setup to Publish Sensor Data
mqttc = paho.Client()
mqttc.on_connect = on_connect
mqttc.on_message = on_message
mqttc.connect(localBroker, localPort, localTimeOut)
```

### Step C9: Modify our WebApp main.py SSE route and method
```python
# =========================== Endpoint: /myData ===============================
# read the sensor values by GET method from curl for example
# curl http://iot8e3c:5000/myData
# -----------------------------------------------------------------------------
@app.route('/myData')
def myData():
    def get_values():
        while True:
            # return the yield results on each loop, but never exits while loop
            data_payload = get_sensor_values()
            yield('data: {0}\n\n'.format(data_payload))
            print("MQTT Topic:"+localTopic, data_payload)
            mqttc.publish(localTopic,data_payload)
            time.sleep(2.0)
    return Response(get_values(), mimetype='text/event-stream')
# ============================== API Routes ===================================
```


### Step C10: Modify Sense.py to include LED display

Add the following two functions from line 24 on the sense.py from Lab6
```python
    # pixel display
    def set_pixel(self,x,y,color):
    # red = (255, 0, 0)
    # green = (0, 255, 0)
    # blue = (0, 0, 255)
        self.sense.set_pixel(x, y, color)

    # clear pixel display
    def clear_display(self):
        self.sense.clear()
```


# STEPS TO MODIFY in ```main.py```
### STEP C11: Initial Import structure
```python 
#!/usr/bin/python
import time
import datetime
from sense import PiSenseHat
import paho.mqtt.client as paho
from flask import *
```

### STEP C12: MQTT Callbacks
```python
# ============================= MQTT Callbacks ================================
# The callback for when a CONNACK message is received from the broker.
def on_connect(client, userdata, flags, rc):
    print("CONNACK received with code %d." % (rc))

# The callback for when a PUBLISH message is received from the broker.
def on_message(client, userdata, msg):
    print (string.split(msg.payload))
# ============================= MQTT Callbacks ================================
```
### STEP C13: LOGIN CONSTANTS and SETUP TO PUBLISH
```python
# MQTT Configuration for local network
localBroker = "iot8e3c"		# Local MQTT broker
localPort   = 1883			# Local MQTT port
localUser   = "pi"			# Local MQTT user
localPass = "raspberry"		# Local MQTT password
localTopic = "iot/sensor"	# Local MQTT topic to monitor
localTimeOut = 120			# Local MQTT session timeout

# Setup to Publish Sensor Data
mqttc = paho.Client()
mqttc.on_connect = on_connect
mqttc.on_message = on_message
mqttc.connect(localBroker, localPort, localTimeOut)
```
### STEP C14: Addition of Publish in our SSE Loop
```python
# =========================== Endpoint: /myData ===============================
# read the sensor values by GET method from curl for example
# curl http://iot8e3c:5000/myData
# -----------------------------------------------------------------------------
@app.route('/myData')
def myData():
    def get_values():
        while True:
            # return the yield results on each loop, but never exits while loop
            data_payload = get_sensor_values()
            yield('data: {0}\n\n'.format(data_payload))
            print("MQTT Topic:"+localTopic, str(data_payload))
            mqttc.publish(localTopic,str(data_payload))
            time.sleep(2.0)
    return Response(get_values(), mimetype='text/event-stream')
```

[PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/PartD.md) Test Multiple Pub/Sub Connections

[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/setup.md)
[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/setup.md)

## Part D - Test Multiple Pub/Sub Connections
**Synopsis:** In this part, we will test multiple in class nodes against the
MQTT gateway device.  We will also set up several gate way device and cross test.

## Objectives
* Assign hostnames for each gateway device
* Ensure Mosquitto is started and running
* Ensure MQTT.fx is started and attached/connected to the Mosquitto server.
* Ensure Publish and observe both MQTT.fx subscriptions, listener and mosquitto_pub

### Step D1: Assign Hostnames
```sh

```    
### Step D2: Ensure Mosquitto is started and running
```sh
pi$ ps aux | grep mosq |
```    
### Step D3: Ensure MQTT.fx is connected to Mosquitto


### Step D4: Publish and Subscribe!


[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/PartC.md) Create MQTT Python Test Code

[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/setup.md)
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up Lab8

**Synopsis:** For this lab we will study gateways and examine the Message Queue
Telemetry Transport (MQTT) protocol in preparation for our last class where we 
create a connection to an instructor led Microsoft Azure IoT Suite connection.

### Objectives
* Install MQTT Message Broker
* Install the MQTT Client Tool (MQTT.fx)
* Create MQTT Test code, Sensor Sim and Update SenseHat Web main.py
* Testing Multiple Pub/Sub Connections

The various steps of this lab are summarized as:
* [PART A](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/PartA.md) Install MQTT Message Broker
* [PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/PartB.md) Install MQTT Client Tool MQTT.fx
* [PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/PartC.md) Create MQTT Python Test Code
* [PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab8/PartD.md) Test Multiple Pub/Sub Connections

[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)
[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/setup.md)

## Part A - Install MQTT on Azure Ubuntu VM
**Synopsis:** In this part, we will install and test MQTT on an Azure Ubuntu Virtual Machine (VM).

## Objectives
* Provision an Azure Ubuntu VM as aan MQTT Broker
* Test the MQTT Pub/Sub Capability
* Setup basic Password Authentication to the MQTT Broker and Test
* Set up SSL Certificates and Test

### Step A1: Provision an Azure VM to act as an MQTT Broker
From Azure Portal Choose an Ubuntu 16 Compute VM.
![Ubuntu 16.04 LTS VM](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/AzureCreateVM.png)

Get SSH public key from development host machine (from the ~/.ssh/id_rsa.pub file created with the ssh-keygen comamnd).

Note: if you have not created a public key please log into a linux shell or Git Bash CLI and perform the following:
```sh
host$ cd ~/.ssh
host$ ssh-keygen        # <= just hit enter for all questions
host$ cat id_rsa.pub    # <= copy the SSH public key to your clipboard
```  

![Ubuntu SSH Keys](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/AzureVM-SSHKeys.png)

### Step A2: Log In & Install Libraries and Mosquitto MQTT Broker
There is a great tutorial found at Digital Ocean concerning installing and testing both
password only and encrypted (SSL) communications between a MQTT client and
MQTT broker (server).  [Digital Ocean MQTT Tutorial](https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-the-mosquitto-mqtt-messaging-broker-on-ubuntu-16-04)

We will adapt that tutorial for our Azure VM example.
```sh
AzureVM$ sudo apt-get update
AzureVM$ sudo apt-get install -y mosquitto mosquitto-clients
AzureVM$ $ ps aux | grep mos
mosquit+  3103  0.0  0.1  35828  4540 ?        S    21:42   0:00 /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf
sdame     3165  0.0  0.0  12944  1084 pts/0    S+   21:43   0:00 grep --color=auto mos
```
Open a subscriber terminal for testing
```sh
AzureVM$ $ mosquitto_sub -h localhost -t test
=> hello MQTT world!
```

Open a publisher terminal for publishing a test message
```sh
AzureVM$ $ mosquitto_pub -h localhost -t test -m "hello MQTT world!"
```

### Step A3: Establish MQTT Password Access on Port 1883
In this step we need to both edit the MQTT configuration file to require a
username and password as well as open a port in the network security resource.

Add a new configuration file in /etc/mosquitto/conf.d (then edit)
```shsudo touch /etc/mosquitto/conf.d/mosquitto.conf
AzureVM$ sudo vim /etc/mosquitto/conf.d/mosquitto.conf
=>...
user mo
listener 1883
allow_anonymous false
password_file /etc/mosquitto/passwd
```

Setup a username ("mo" and password "squitto")

```sh
AzureVM$ sudo mosquitto_passwd -c /etc/mosquitto/passwd mo
Password: ******* (<= "squitto")
Reenter password: ******** (<= "squitto")

```


[PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/PartB.md)  Install MQTT Client Tool MQTT.fx

[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/setup.md)
[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/setup.md)

## Part B - Create and Configure Devices for Azure IoT Hub
**Synopsis:** In this part, we will configure Azure IoT Hub.

## Objectives
* Provision an Azure IoT Hub

### Step B1: Create Azure IoT Hub
From Azure Portal Choose an Ubuntu 16 Compute VM.
![Azure IoT Hub]()

[npm package iothub explorer](https://www.npmjs.com/package/iothub-explorer)

[iothub-explorer https://github.com/Azure/iothub-explorer/blob/master/readme.md

### Step B2: Setup iothub-explorer
```sh
pi$ sudo apt-get update
pi$ sudo apt-get install -y nodejs
pi$ sudo apt install -y npm
pi$ sudo npm install -g iothub-explorer
pi$ iothub-explorer login "HostName=<<host>>;SharedAccessKeyName=service;SharedAccessKey=<<key>>"
Session started, expires on Sun Mar 05 2017 18:20:05 GMT-0800 (PST)
Session file: /home/pi/.iothub-explorer

https://github.com/Azure/azure-iot-sdk-python
git clone --recursive https://github.com/Azure/azure-iot-sdk-python.git

 => looking down in the service samples directory there is a iothub_messaging_sample.py
 => the standard ConnectionString is not parseable by this current code because it contains

AzureVM$ iothub-explorer list | grep foo
 deviceId:                   foo
 connectionString:           HostName=Iot110-hub.azure-devices.net;DeviceId=foo;SharedAccessKey=PyOxlqIITtqi3K7Jypw9Kg3vWgvMveJCbqSh0O+Q6c0=

 => DeviceId=foo  vs. SharedAccessKeyName=foo ???
AzureVM$ python iothub_messaging_sample.py -c "HostName=Iot110-hub.azure-devices.net;SharedAccessKeyName=foo;SharedAccessKey=PyOxlqIITtqi3K7Jypw9Kg3vWgvMveJCbqSh0O+Q6c0=" -d foo

iothub-explorer send foo 'hello9994' --ack=full

iothub-explorer monitor-feedback foo

iothub-explorer simulate-device --protocol=mqtt foo --receive




python iothub_message_demo.py -c "HostName=Iot110-hub.azure-devices.net;SharedAccessKeyName=device;SharedAccessKey=c6Glzei6IkM42CF9/ZuVknH/7OqbC+LaQVe4k7JaxO0=" -d foo


```

```sh
AzureVM$ sudo ln -s /usr/bin/nodejs /usr/bin/node
```

### Step B3: Login to IoT Hub via iothub-explorer
```sh
iothub-explorer login "HostName=<<host>>;SharedAccessKeyName=service;SharedAccessKey=<<key>>"
```

### Step B4: Create device <foo> via iothub-explorer
```sh
iothub-explorer create foo
```

### Step B5: Create device <foo> via iothub-explorer
```sh
iothub-explorer create foo
```

### Step B6: List all devices on IoT Hub via iothub-explorer
```sh
iothub-explorer list

iothub-explorer list |  grep foo
iothub-explorer list |  grep bar

```

### Step B7: Monitor Events for Device to Cloud (D2C)
```sh
iothub-explorer monitor-events foo --login "HostName=Iot110-hub.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=c6Glzei6IkM42CF9/ZuVknH/7OqbC+LaQVe4k7JaxO0="
```

### Step B8: Send Simulated Message from Device to Cloud (D2C)
```sh
iothub-explorer simulate-device foo --send "{deviceId: 'foo', windSpeed: 10.671534826979041 }"
```

### Step B9:


[PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/PartB.md)  TBD

[LAB8 INDEX](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/setup.md)
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up Lab9

**Synopsis:** For this lab we will extend the introduction to MQTT and IoT edge
devices by connecting to the UW/instructor provisioned Microsoft Azure cloud
system and the Azure IoT Suite.  We will perform manual connections to an MQTT
Broker on the Azure cloud, provision security certificates, connect to the Azure
IoT Hub, perform a basic Stream Analytics function and Utilize the Power BI
visualization toolkit to graph data from multiple IoT devices.

### Objectives
* Install MQTT Message Broker on an Azure Ubuntu VM
* Generate Certificates for IoT End Devices or Gateways
* Connect our IoT Gateway code to Azure IoT Hub
* Stream data through Stream Analytics
* Perform Visualization using Power BI


The various steps of this lab are summarized as:
* [PART A](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/PartA.md) Install MQTT Message Broker on an Azure Ubuntu VM
* [PART B](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/PartB.md) Generate Certificates for IoT End Devices or Gateways
* [PART C](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/PartC.md) Create MQTT Python Test Code
* [PART D](https://gitlab.com/iot110/iot110-student/blob/master/Labs/Lab9/PartD.md) Test Multiple Pub/Sub Connections

[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)

## Setting up RPi3 for the IoT110 Class

### Summary of Setup Steps
* [OPT] Download OS from RaspberryPi Foundation
* ( 1) Set Hardcoded Screen Resolution for mini HDMI monitor
* ( 2) Expand the filesystem
* ( 3) Setup WiFi connection
* ( 4) Establish a Command Line Interface (CLI)
* ( 5) Ensure a US Keyboard mapping
* ( 6) Set up a hostname unique for your PI (using its last 4 digits MAC address for wlan)
* ( 7) Enable Serial Ports and GPIO for Labs
* ( 8) Set up local hostname resolution for the IOT class (or home) network
* ( 9) SSH -> iot1234
* (10) Mapping PI filesystem into host's
* (11) Update OS and install a few utilities and check versions
* (12) Set up a Project for this Class in GITLAB and push ssh key(s)

<hr>
### [OPTIONAL] Downloading and burning a new image (if you wish to have the latest OS or burn your own image)
[RASPBIAN JESSIE WITH PIXEL](https://www.raspberrypi.org/downloads/raspbian/)
Image with PIXEL desktop based on Debian Jessie

[RASPBIAN JESSIE LITE](https://www.raspberrypi.org/downloads/raspbian/)
Minimal image based on Debian Jessie

[Optional Configuration Link](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-2-first-time-configuration/using-the-whole-sd-card?view=all)
<hr>
### STEP 1: Mini Display 480x800 pixels
This display will not boot a screen on default.  The config.txt file must be
modified according to the instructions on Adafruit.  (config.txt is located on the SD card and you must insert the card into your host computer to edit)
[Display Config Changes](https://learn.adafruit.com/adafruit-5-800x480-tft-hdmi-monitor-touchscreen-backpack/raspberry-pi-config)
In case that site goes down, here's a summary of the changes in config.txt:
```
# uncomment if hdmi display is not detected and composite is being output
hdmi_force_hotplug=1

# uncomment to force a specific HDMI mode (here we are forcing 800x480!)
hdmi_group=2
hdmi_mode=87
hdmi_cvt=800 480 60 6 0 0 0
```
<hr>
#### [GENERAL INFO] Check the Raspberry PI Settings/Preferences
Start > Preferences > Raspberry Pi Configuration
![Raspberry Pi Settings](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/Preferences.png)

<hr>

### STEP 2: Expanding Filesystem
**Objective:** The default SD card operating systems shipped out of the box
often are not expanded to the full extent of the size of the SD card.  This is
also true if you have downloaded an operating system image (see above) and
burned it onto the card.  The image size may only be 1-2GB but the card might be
8GB to 64GB for example.  We therefore will want to have ALL of the SD card
file system available to the RPi. It is very important to do this at the **VERY
BEGINNING OF SETUP** otherwise you may find yourself out of disk space and in a
"bricked" state.  In this case, you will need to perform the OPTIONAL step above
and start over with a fresh image install.<br><br>
![Expand File System](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/expand.png)

After expanding and rebooting as required, open a terminal and check to ensure
that the filesystem was indeed expanded.<br><br>
![File System Size Check](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/df_dash_h.png)
<br>
<hr>
### STEP 3: Setup WiFi Connection
Apple Airport access points have been configured for our IoT classroom.  There
are 2 access points because they each have a limit of 50 client connections.  
To attempt to keep things simple we will join to only one of the access points
(UW-IoT110-R) until we either have:<br>
a) run out of 50 client connections<br>
  or<br>
b) we have a failure on one access point.<br>
*(Being airplane engineers we tend to think in terms of redundancy!) (grin)*<br>

Using the mouse and hovering over the WiFi connection ICON, select SSID and
enter the password given below:<br>
Airports have SSIDs of UW-IoT110-R (primary) and UW-IoT110-L (secondary).  
Password: **piIoT110**  (Note: "I" in IoT is  "capital I" and not "capital L")
<br><br>
![WiFi Settings Panel](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/SSID.png)
<br>
<hr>
### STEP 4: Command line shell ###
For MacOSX or Linux users, just use the normal "terminal" for your Command Line
Interface (CLI).<br>

For Windows users, it maybe best to download the GIT Bash tool (git is built
into Linux and MacOSX terminal shells).
[Download GIT](https://git-scm.com/downloads)

NOTE: For the following command line entries we use the following to
indicate which machine you are on.
```
pi$  => this is a command on the RPi3

host$ => this is a command on your development host
```

#### Check to see if connected to the public Internet
```
pi$ ping google.com
```

#### Determine IP address of RPi
```
pi$ ifconfig | grep "inet addr"
=> inet addr:192.168.10.19  Bcast:192.168.1.255  Mask:255.255.255.0
```

### Step 5: Ensure a US Keyboard Mapping
![Keyboard Setting](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/Keyboard.png)


### Step 6: Setup a unique hostname based on wlan MAC
```
pi$ ifconfig | grep wlan0  
=> wlan0     Link encap:Ethernet  HWaddr b8:27:eb:e9:12:34  
=> choose the last 4 digits of the MAC => [1234]

pi$ sudo vi /etc/hostname

=> remove current hostname and replace with "iot1234"
=> using the [HWaddr] from above network queries
```
Alternatively the hostname can be set from the Preferences panel.
![Hostname Preferences UI](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/hostname.png)

### Step 7: Enable I2C Serial Port (and GPIO if Pixel OS) for Labs
![Raspberry Pi I/O Port Settings](https://gitlab.com/iot110/iot110-student/raw/master/Resources/Images/interfaces.png)

#### Reboot
```
pi$ reboot
```

<hr>
### STEP 8: Using Hostname Resolution on Network
```
// start the avahi-daemon network service
pi$ systemctl status avahi-daemon
  => Verify that the hostname matches the name changed to above
Loaded: loaded (/lib/systemd/system/avahi-daemon.service; enabled)
Active: active (running) since Sun 2016-11-13 23:15:20 UTC; 15min ago
Main PID: 438 (avahi-daemon)
  Status: "avahi-daemon 0.6.31 starting up."
  CGroup: /system.slice/avahi-daemon.service
          438 avahi-daemon: running [iot1234.local]
          465 avahi-daemon: chroot helper

host$ ping iot1234
PING iot1234.home (192.168.10.19): 56 data bytes
64 bytes from 192.168.10.19: icmp_seq=0 ttl=64 time=10.863 ms
64 bytes from 192.168.10.19: icmp_seq=1 ttl=64 time=7.657 ms
64 bytes from 192.168.10.19: icmp_seq=2 ttl=64 time=7.024 ms      

```
<hr>
### STEP 9: Setting up SSH
**Objective:** Establishing ssh connection is the most universal way to connect
two computers together over a network (local or global).  This also automatically
provides public key infrastructure (PKI) security which is the standard for
Internet Security.  Establishing SSH keys allows for password free log in
between systems which is not only convenient (when a trust is established) but
essential when automating connectivity --as we will be doing for our class.  We
will be using SSH to routinely log into our machines as well as utilizing a
capbility known as SSHFS (i.e. File System mapping over SSH).

```
// ------- RPi KEY SETUP ----------
// log into RPi iot1234 (with password => "raspberry")
host$ ssh pi@iot1234  // answer yes to the one time prompt for host signature
                            // passwd default: "raspberry"
pi$ cd .ssh                 // change dir to .ssh if it exists, mkdir if it doesn't
pi$ ssh-keygen              // generate an ssh key (RSA)
=> Enter file in which to save the key (/home/pi/.ssh/id_rsa):
                            // hit <enter> 3 times

pi$ cp id_rsa.pub  id_rsa_iot1234.pub
pi$ exit                    // success! now exit and set up an SSH key for host
```

**(IF YOU ALREADY HAVE AN SSH HOST KEY PLEASE SKIP THE HOST PORTION)**

```
// ------- HOST KEY SETUP ----------
// generatate (or use) a ssh key on the host (IF YOU ALREADY HAVE A KEY
host$ cd ~/.ssh
host$ ssh-keygen            
=> Enter file in which to save the key (/home/pi/.ssh/id_rsa):
                            // hit <enter> 3 times

host$ cp id_rsa.pub id_rsa_XYZ.pub  // Use a unique XYZ id from your host machine
host$ scp id_rsa_XYZ.pub pi@iot1234:.ssh
host$ ssh pi@iot1234                // enter passwd (for the last time!)

// install the ssh host key on iot708c
pi$ cd .ssh
pi$ cat id_rsa_XYZ.pub >> authorized_keys
pi$ exit  

// test the ssh key
host$ ssh pi@iot1234  // should be passwd free now!
pi$ exit  
```
<hr>
### STEP 10: Mapping PI filesystem into host's
**Objective:** It is *very convenient* to map the RPi's filesystem into your
development host as if it is just another folder on your host.  This allows the
use of native and powerful code friendly editors (e.g. Atom or Sublime) in which
to edit source code.  Because the RPi's file system is mapped there is no need
to transfer code back and forth to the RPi.  In Linux-speak mapping a target
filesystem like this is known as *mounting the file system*.

Create a folder on the RPi under ```Documents/``` called ```GIT_REPOS``` 
(e.g. Documents/GIT_REPOS)

Must install sshfs capability in order to mount file system then...
#### sshfs for MacOSX
[FUSE for macOS](https://osxfuse.github.io/)   // install **BOTH** fuse and sshfs pkgs

Create directories on development host to mount each PI (e.g. PI_MOUNT_1234)
then mount them using sshfs.

``` sh
host$ sshfs pi@iot1234:Documents/GIT_REPOS PI_MOUNT_1234/ -C

```

disconnect from the PI file systems
```
host$ umount PI_MOUNT_1234/
```

#### sshfs for Windows 7/8/10
[SSHFS Win10](https://igikorn.com/sshfs-windows-10/)   // install Win sshfs pkg

Follow the instructions to set up a GUI based SSHFS capability for Windows
development hosts.

<hr>
### STEP 11: Update OS and install a few utilities and check versions
**Objective:** It is always a good idea to keep Linux systems such as the
Debian OS (Raspbian) updated with the latest improvements coming from the large
open source community such as enjoyed by the Raspberry Pi platform.  As a final
stage of our PI setup we will make sure we have an updated OS.

``` bash
host$ ssh pi@iot1234

pi$ sudo apt install rpi-update
pi$ sudo rpi-update
pi$ uname -a

```
<hr>
### STEP 12: Setting up GIT Repositories
**Objective:** We will be making use of GIT (Distributed Software Version Control)
to ensure that each student's projects are safely backed up and under version
control.
* create an account on GITLAB (or other GIT services if you have a preference)
* log in and create a project called iot-110
* clone this project into a folder on your HOST (e.g. Documents/GIT_REPOS)
* clone this project into a folder on your PI (e.g. Documents/GIT_REPOS)

[IOT STUDENT HOME](https://gitlab.com/iot110/iot110-student/blob/master/README.md)
