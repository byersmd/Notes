# Welcome to the IOT 210B: Internet of Things: Protocols & Networks

This course focuses on connecting devices to the cloud. You’ll be introduced to
networking, frameworks, application protocols, data representations, security and
the tools used to connect devices to the internet of things. This course builds on
what you learned in the first course (110A), using the Raspberry Pi to understand how
things are connected and represented on the internet. Some of the networks we’ll cover
include ZigBee, Thread, Bluetooth and WiFi. You’ll explore ecosystems such as IFTT,
Amazon Skills Kit (ASK), and Philips Hue.

This course does not assume any prior knowledge of networking protocols.

This course does assume some amount of Python programming ability.

## Disclaimer

The materials of this course are the property of the University of Washington, and
are not to be posted on the internet or other forums.

They are for the personal use of the students attending the course.


## Instructor and Classroom Information

**Online Meeting Room:** https://uwtest.zoom.us/j/583388263

**Instructor: Drew Gislason**, Email: gislad@uw.edu

**TA: Bryan Palmer**, Email: bpalmer@uw.edu

**Class Sessions:** Thursdays 6:00pm - 9:00pm Pacific, March 30th - June 1st, 2017

**Class Location:** 2445 140th Avenue N.E., Ste. B-100, Bellevue, WA 98005-1879 (Links to an external site.), Room 210

**In-Class Wi-Fi:**  
SSID: **UW-IoT110-R**  
Password: **piIoT110**  (Note: "I" in IoT is  "capital I" and not "capital L")

Topics include:

* Networking and application protocols
* How data is represented on the internet
* Connecting devices to the internet of things
* Securing devices and transactions
* IOT Ecosystems (e.g IFTTT, Philips Hue, Amazon Web Services and Alexa)

## Various Links

[UW-PCE IoT Website](https://www.pce.uw.edu/certificates/internet-of-things)  
[IOT 210B: INTERNET OF THINGS: PROTOCOLS & NETOWRKS](https://www.pce.uw.edu/internet-of-things-protocols-and-networks)  
[Canvas](https://canvas.uw.edu/courses/1113347/pages/front-page)  
[GitLab Home for Labs](https://gitlab.com/Gislason/iot-210B-student)  
[GitLab Home for Slides](https://gitlab.com/Gislason/iot-210B-slides)  

## Setting up RPi3

[RPi3 Setup](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/PI_SETUP.md)

## Assignments and Syllbus

Week | Date | Lab | Description
----- | ------ | ---- | -----
W1 | Mar 30 | [Lab 1](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab1/lab.md) | Setup, Introduction to Networking (OSI 7-Layer Model), TCP/IP, UDP/IP, Sockets
W2 | Apr 6  | [Lab 2](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab2/lab.md) | HTTP, REST, URLs, APIs, Curl, UDP Multicast, Heroku, IPv6 vs IPv4
W3 | Apr 13 | [Lab 3](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab3/lab.md) | JSON vs XML, SSE vs Websockets, MQTT with MQTT-SN, Google Protobufs
W4 | Apr 20 | [Lab 4](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab4/lab.md) | ZigBee Part 1
W5 | Apr 27 | [Lab 5](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab5/lab.md) | ZigBee Part 2
W6 | May 4  | [Lab 6](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab6/lab.md) | ZigBee Part 3, Bluetooth, 6LoWPAN (Thread)
W7 | May 11 | [Lab 7](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab7/lab.md) | Securing IoT Devices and Transactions
W8 | May 18 | [Lab 8](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab8/lab.md) | Philips Hue API, Twitter, other APIs
W9 | May 25 | [Lab 9](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab9/lab.md) | Amazon AWS IoT and Alexa API
W10 | Jun 1 | n/a   | Capstone Projects (Hackathon)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Homework Week 1

The homework for this week is to complete the Week1 Lab, All parts A-C.

**Reminder: GitLab Repo with your instructor [Drew Gislason](emailto:gislad@uw.edu?subject=GitLab Repo)

This includes all of the following

* Set up Raspberry Pi 3
* Installed Python 2.7
* Installed Flask (python library)
* Installed sense_hat (python library)
* Program to display IPv4 address on boot-up (ipaddr.py)
* Installed Git
* Git clone https://gitlab.com/Gislason/iot-210B-student into Pi3
* Ran and explored the ipv4_udp_server.py, ipv4_udp_client.py
  ipv4_tcp_server.py, ipv4_tcp_client.py which use sockets

The instructions for these can be found in the following files

[Lab Overview](https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab1/lab.md)
[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartA.md) Setup  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartB.md) RPi3 SenseHat and Autoboot  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartC.md) Sockets 

# Main Project Links

[Canvas](https://canvas.uw.edu/courses/1113347/pages/front-page)  
[GitLab Home for Labs](https://gitlab.com/Gislason/iot-210B-student)  
[GitLab Home for Slides](https://gitlab.com/Gislason/iot-210B-slides)  
 

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Week 1 - Setup, Introduction to Networking (OSI 7-Layer Model), TCP/IP, UDP/IP, Sockets

## Lab Objectives

In this lab you'll learn the following:

* How to setup your Raspberry Pi 3, and all of the tools we'll use for this lab
* How to use SSH (for a headless Pi3)
* The OSI 7-Layer Model of networking
* Where to find specifications for the various layers
* TCP/IP vs UDP/IP
* What a socket is, and how to program sockets in Python
* A Practical way to boot into a Python program on the Raspberry Pi3

## Details

1. **Lecture:** First, we'll have a brief introductory **lecture** about the course, the instructor,
the Internet of Things.
2. **Lab:** In Part A of this lab, you will set up your Raspberry Pi3 (Pi3) and GitLab so you
are ready for the rest of the course. Those who took course 110A have already done
this step.
3. **Lecture:** Next, we'll have a **lecture** about the OSI 7 Layer Model of Networking and explore some
networking concepts.
4. **Lab:** Part B of this lab shows how to set up the Raspberry Pi3 to Autoboot into a program.
Specifically, this Python program will display the IP address of your Pi3 (ipaddr.py).
5. **Lecture:** Another lecture, this time on sockets. What is a socket, how does it work?
6. **Lab:** Part C of this lab will use **sockets** to send/recieve packets, both under
TCP/IP and UDP/IP


## Homework

See the homework link below.

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartA.md) Setup  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartB.md) RPi3 SenseHat and Autoboot  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartC.md) Sockets  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/homework.md) Run through all the labs (Parts A, B and C)  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab1 - PartA (Setup)

In this section of the lab you will

* Set up your Raspberry Pi3
* Install Python 2.7 on Rpi3
* Install Flask Python Library on Rpi3
* Install SenseHat Python Library on Rpi3
* Create a GitLab repo for this class
* Clone the Student GitLab repo on RPi3

## Setup Rpi3

[RPi3 Setup](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/PI_SETUP.md)

## Install Python

[Install Python](https://www.python.org)

## Install Pip

[Install Pip](https://pip.pypa.io/en/stable/installing/)

## Install Flask Python Library

[Install Flask](http://flask.pocoo.org/docs/0.12/installation)

Or simply use pip:  
```
pi$ pip install Flask
```

## Install SenseHat Python Library

![SenseHat](https://gitlab.com/Gislason/iot-210B-student/raw/master/images/rpi_sensehat.png)

The SenseHat library is used to interact with the various sensors and actuators on the
SenseHat device.

```
pi$ pip install sense_hat
```

## Install Git and Curl

Git comes pre-installed on both MAC and The Raspberry Pi 3.

### Install Git on Windows

[Git Tools, includes Curl](https://git-scm.com)

## Git Training

[Git Training](https://try.github.io/levels/1/challenges/1)

## Create GitLab Repo

Create an account if needed (if you don't already have a GitLab account). Then create a
project named something like "iot210-MyName".

Share a link to this project with your instructor Drew Gislason: [gislad@uw.edu](emailto:gislad@uw.edu?subject=GitLab Repo)

See [GitLab](http://www.gitlab.com)

## Clone the Student GitLab Repo

Choose a place for Git Repos and clone the repo

```
cd /where/i/keep/my/git/repos
git clone https://gitlab.com/Gislason/iot-210B-student.git
```

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartA.md) Setup  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartB.md) RPi3 SenseHat and Autoboot  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartC.md) Sockets  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/homework.md) Run through all the labs (Parts A, B and C)  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab1 - PartB (RPi3 SenseHat and Quiz)

![SenseHat](https://gitlab.com/Gislason/iot-210B-student/blob/master/images/rpi_sensehat.png)

In this section of the lab you will

* Learn how to get your local IP Address and autoboot into program
* Explore the SenseHat features

## Autoboot

With an embedded device, it's sometimes useful to boot the device headless (no keyboard
or screen). SSH works well as a terminal window into the device.

Source code is in the `iot-210B-student/Lab1/src` folder.

Copy the file `ipaddr.py` to the Pi3 home directory

```
scp Lab1/src/ipaddr.py pi@iotXxxx/home/pi
```

Add the following line to /etc/rc.local near the end (just before exit 0)

```
python /home/pi/ipaddr.py &
```

Cold boot your Pi3. Once Linux boots up, it should display a 'P' to help you orient
your SenseHat display. Then (after about 10 seconds), it will display your IP address

```
10.0.1.8
```

A couple of improvements that could be made to ipaddr.py:

1. Find a better way to get your local IP address other than connecting to an external site
2. Find a way to know when Wi-Fi has completed connecting and is ready for use


## Explore SenseHat

If you haven't already, install sense_hat package for python.

```
pip install sense_hat
```

In the `iot-210B-student/docs` folder you will find 'Essentials_SenseHAT_v1.pdf`

Open that file and try out the examples in your RPI3. 

Make a Python Program that does something interesting. Show your instructor (or cat
if working remotely)

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartA.md) Setup  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartB.md) RPi3 SenseHat and Autoboot  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartC.md) Sockets  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/homework.md) Run through all the labs (Parts A, B and C)  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab1 - PartC (Sockets)

In this section of the lab you will

* Learn the difference between TCP/IP and UDP/IP
* Learn how to use sockets from both a Client and Server Perspective

These apps can be run from the Raspberry Pi in terminal windows, or on your PC

## UDP

From `iot-210B-student/Lab1/src` 

In one terminal window, run:  
```
$ python ipv4_udp_server.py
```

The server will sit and wait for incoming packets

In another terminal window, run:  
```
$ python ipv4_udp_client.py
```

Experiment with different IP ports and messages. You can even send a message to someone else's
PI.

```
$ python ipv4_udp_client.py message ip_addr port
```

Ports can be anything from 1024 - 65000. Ports < 1024 are reserved for various services.


## TCP

From `iot-210B-student/Lab1/src` 

In one terminal window, run:  
```
$ python ipv4_tcp_server.py
```

The server will sit and wait for an incoming connection

In another terminal window, run:  
```
$ python ipv4_tcp_client.py
```

Experiment with different IP ports and messages. You can even send a message to someone else's
PI.

```
$ python ipv4_tcp_client.py message ip_addr port
```

Ports can be anything from 1024 - 65000. Ports < 1024 are reserved for various services.

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartA.md) Setup  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartB.md) RPi3 SenseHat and Autoboot  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/LabPartC.md) Sockets  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab1/homework.md) Run through all the labs (Parts A, B and C)  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

## Setting up RPi3 for the IoT 110,210,320 Classes

### Summary of Setup Steps
* [OPT] Download OS from RaspberryPi Foundation
* ( 1) Set Hardcoded Screen Resolution for mini HDMI monitor
* ( 2) Expand the filesystem
* ( 3) Setup WiFi connection
* ( 4) Establish a Command Line Interface (CLI)
* ( 5) Ensure a US Keyboard mapping
* ( 6) Set up a hostname unique for your PI (using its last 4 digits MAC address for wlan)
* ( 7) Enable Serial Ports and GPIO for Labs
* ( 8) Set up local hostname resolution for the IOT class (or home) network
* ( 9) SSH -> iot1234
* (10) Mapping PI filesystem into host's
* (11) Update OS and install a few utilities and check versions

<hr>
### [OPTIONAL] Downloading and burning a new image (if you wish to have the latest OS or burn your own image)
[RASPBIAN JESSIE WITH PIXEL](https://www.raspberrypi.org/downloads/raspbian/)
Image with PIXEL desktop based on Debian Jessie

[RASPBIAN JESSIE LITE](https://www.raspberrypi.org/downloads/raspbian/)
Minimal image based on Debian Jessie

[Optional Configuration Link](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-2-first-time-configuration/using-the-whole-sd-card?view=all)
<hr>
### STEP 1: Mini Display 480x800 pixels

**Skip this step if using a desktop HDMI display (as opposed to the the one used in Class IoT 110A.**

This display will not boot a screen on default.  The config.txt file must be
modified according to the instructions on Adafruit.  (config.txt is located on the SD card and you must insert the card into your host computer to edit)
[Display Config Changes](https://learn.adafruit.com/adafruit-5-800x480-tft-hdmi-monitor-touchscreen-backpack/raspberry-pi-config)
In case that site goes down, here's a summary of the changes in config.txt:
```
# uncomment if hdmi display is not detected and composite is being output
hdmi_force_hotplug=1

# uncomment to force a specific HDMI mode (here we are forcing 800x480!)
hdmi_group=2
hdmi_mode=87
hdmi_cvt=800 480 60 6 0 0 0
```
<hr>
#### [GENERAL INFO] Check the Raspberry PI Settings/Preferences
Start > Preferences > Raspberry Pi Configuration
![Raspberry Pi Settings](https://gitlab.com/Gislason/iot-210B-student/raw/master/images/Preferences.png)

<hr>

### STEP 2: Expanding Filesystem
**Objective:** The default SD card operating systems shipped out of the box
often are not expanded to the full extent of the size of the SD card.  This is
also true if you have downloaded an operating system image (see above) and
burned it onto the card.  The image size may only be 1-2GB but the card might be
8GB to 64GB for example.  We therefore will want to have ALL of the SD card
file system available to the RPi. It is very important to do this at the **VERY
BEGINNING OF SETUP** otherwise you may find yourself out of disk space and in a
"bricked" state.  In this case, you will need to perform the OPTIONAL step above
and start over with a fresh image install.<br><br>
![Expand File System](https://gitlab.com/Gislason/iot-210B-student/raw/master/images/expand.png)

After expanding and rebooting as required, open a terminal and check to ensure
that the filesystem was indeed expanded.<br><br>
![File System Size Check](https://gitlab.com/Gislason/iot-210B-student/raw/master/images/df_dash_h.png)
<br>
<hr>
### STEP 3: Setup WiFi Connection
Apple Airport access points have been configured for our IoT classroom.  There
are 2 access points because they each have a limit of 50 client connections.  
To attempt to keep things simple we will join to only one of the access points
(UW-IoT110-R) until we either have:<br>
a) run out of 50 client connections<br>
  or<br>
b) we have a failure on one access point.<br>

Using the mouse and hovering over the WiFi connection ICON, select SSID and
enter the password given below:<br>
Airports have SSIDs of UW-IoT110-R (primary) and UW-IoT110-L (secondary).  
Password: **piIoT110**  (Note: "I" in IoT is  "capital I" and not "capital L")
<br><br>
![WiFi Settings Panel](https://gitlab.com/Gislason/iot-210B-student/raw/master/images/SSID.png)
<br>
<hr>
### STEP 4: Command line shell ###
For MacOSX or Linux users, just use the normal "terminal" for your Command Line
Interface (CLI).<br>

For Windows users, it maybe best to download the GIT Bash tool (git is built
into Linux and MacOSX terminal shells).
[Download GIT](https://git-scm.com/downloads)

NOTE: For the following command line entries we use the following to
indicate which machine you are on.
```
pi$  => this is a command on the RPi3

host$ => this is a command on your development host (Windows PC or MAC)
```

#### Check to see if connected to the public Internet
```
pi$ ping google.com
```

#### Determine IP address of RPi
```
pi$ ifconfig | grep "inet addr"
=> inet addr:192.168.10.19  Bcast:192.168.1.255  Mask:255.255.255.0
```


### Step 5: Ensure a US Keyboard Mapping
![Keyboard Setting](https://gitlab.com/Gislason/iot-210B-student/raw/master/images/Keyboard.png)


### Step 6: Setup a unique hostname based on wlan MAC
```
pi$ ifconfig | grep wlan0  
=> wlan0     Link encap:Ethernet  HWaddr b8:27:eb:e9:12:34  
=> choose the last 4 digits of the MAC => [1234]

pi$ sudo vi /etc/hostname

=> remove current hostname and replace with "iot1234"
=> using the [HWaddr] from above network queries
```
Alternatively the hostname can be set from the Preferences panel.
![Hostname Preferences UI](https://gitlab.com/Gislason/iot-210B-student/raw/master/images/hostname.png)

### Step 7: Enable I2C Serial Port (and GPIO if Pixel OS) for Labs
![Raspberry Pi I/O Port Settings](https://gitlab.com/Gislason/iot-210B-student/raw/master/images/interfaces.png)

#### Reboot
```
pi$ reboot
```

<hr>
### STEP 8: Using Hostname Resolution on Network
```
// start the avahi-daemon network service
pi$ systemctl status avahi-daemon
  => Verify that the hostname matches the name changed to above
Loaded: loaded (/lib/systemd/system/avahi-daemon.service; enabled)
Active: active (running) since Sun 2016-11-13 23:15:20 UTC; 15min ago
Main PID: 438 (avahi-daemon)
  Status: "avahi-daemon 0.6.31 starting up."
  CGroup: /system.slice/avahi-daemon.service
          ├─438 avahi-daemon: running [iot1234.local]
          └─465 avahi-daemon: chroot helper

host$ ping iot1234
PING iot1234.home (192.168.10.19): 56 data bytes
64 bytes from 192.168.10.19: icmp_seq=0 ttl=64 time=10.863 ms
64 bytes from 192.168.10.19: icmp_seq=1 ttl=64 time=7.657 ms
64 bytes from 192.168.10.19: icmp_seq=2 ttl=64 time=7.024 ms      

```
<hr>
### STEP 9: Setting up SSH
**Objective:** Establishing ssh connection is the most universal way to connect
two computers together over a network (local or global).  This also automatically
provides public key infrastructure (PKI) security which is the standard for
Internet Security.  Establishing SSH keys allows for password free log in
between systems which is not only convenient (when a trust is established) but
essential when automating connectivity --as we will be doing for our class.  We
will be using SSH to routinely log into our machines as well as utilizing a
capbility known as SSHFS (i.e. File System mapping over SSH).

```
// ------- RPi KEY SETUP ----------
// log into RPi iot1234 (with password => "raspberry")
host$ ssh pi@iot1234  // answer yes to the one time prompt for host signature
                            // passwd default: "raspberry"
pi$ cd .ssh                 // change dir to .ssh if it exists, mkdir if it doesn't
pi$ ssh-keygen              // generate an ssh key (RSA)
=> Enter file in which to save the key (/home/pi/.ssh/id_rsa):
                            // hit <enter> 3 times

pi$ cp id_rsa.pub  id_rsa_iot1234.pub
pi$ exit                    // success! now exit and set up an SSH key for host
```

**(IF YOU ALREADY HAVE AN SSH HOST KEY PLEASE SKIP THE HOST PORTION)**

```
// ------- HOST KEY SETUP ----------
// generatate (or use) a ssh key on the host (IF YOU ALREADY HAVE A KEY
host$ cd ~/.ssh
host$ ssh-keygen            
=> Enter file in which to save the key (/home/pi/.ssh/id_rsa):
                            // hit <enter> 3 times

host$ cp id_rsa.pub id_rsa_XYZ.pub  // Use a unique XYZ id from your host machine
host$ scp id_rsa_XYZ.pub pi@iot1234:.ssh
host$ ssh pi@iot1234                // enter passwd (for the last time!)

// install the ssh host key on iot708c
pi$ cd .ssh
pi$ cat id_rsa_XYZ.pub >> authorized_keys
pi$ exit  

// test the ssh key
host$ ssh pi@iot1234  // should be passwd free now!
pi$ exit  
```
<hr>
### STEP 10: Mapping PI filesystem into host's
**Objective:** It is *very convenient* to map the RPi's filesystem into your
development host as if it is just another folder on your host.  This allows the
use of native and powerful code friendly editors (e.g. Atom or Sublime) in which
to edit source code.  Because the RPi's file system is mapped there is no need
to transfer code back and forth to the RPi.  In Linux-speak mapping a target
filesystem like this is known as *mounting the file system*.

Create a folder on the RPi under ```Documents/``` called ```GIT_REPOS``` 
(e.g. Documents/GIT_REPOS)

Must install sshfs capability in order to mount file system then...
#### sshfs for MacOSX
[FUSE for macOS](https://osxfuse.github.io/)   // install **BOTH** fuse and sshfs pkgs

Create directories on development host to mount each PI (e.g. PI_MOUNT_1234)
then mount them using sshfs.

``` sh
host$ sshfs pi@iot1234:Documents/GIT_REPOS PI_MOUNT_1234/ -C

```

disconnect from the PI file systems
```
host$ umount PI_MOUNT_1234/
```

#### sshfs for Windows 7/8/10
[SSHFS Win10](https://igikorn.com/sshfs-windows-10/)   // install Win sshfs pkg

Follow the instructions to set up a GUI based SSHFS capability for Windows
development hosts.

<hr>
### STEP 11: Update OS and install a few utilities and check versions
**Objective:** It is always a good idea to keep Linux systems such as the
Debian OS (Raspbian) updated with the latest improvements coming from the large
open source community such as enjoyed by the Raspberry Pi platform.  As a final
stage of our PI setup we will make sure we have an updated OS.

``` bash
host$ ssh pi@iot1234

pi$ sudo apt install rpi-update
pi$ sudo rpi-update
pi$ uname -a

```

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

A Special Thank You to Josh Welschmeyer for the Heroku instructions

# Homework

The homework is to set up your own Heroku account and host quizical.py (or your own app).
Provide a link to your instructor.

**Important:** create a NEW folder NOT inside your student repository, as you can't have a git
repository inside another one.

```
  my_student_git_repo
  my_heroku_git_repo
```

Heroku URLs use two random words, and a random # (e.g. frozen-castle-53348)

# Installing and Running Heroku Steps in Detail

## Step 1) Sign Up / Verify Account etc.

[http://www.heroku.com](http://www.heroku.com)

## Step 2) Setting up local machine

### Install Python 2.7

- Windows [http://docs.python-guide.org/en/latest/starting/install/win/](http://docs.python-guide.org/en/latest/starting/install/win/)

- OSX [http://docs.python-guide.org/en/latest/starting/install/osx/](http://docs.python-guide.org/en/latest/starting/install/osx/)

- Linux [http://docs.python-guide.org/en/latest/starting/install/linux/](http://docs.python-guide.org/en/latest/starting/install/linux/)


### Install Depenedencies

#### Install Pip

Download [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py)

- Windows / OSX `python get-pip.py`

- Linux (sudo apt-get install python-pip)

#### Other Dependencies

- sudo pip install flask

#### Install heroku CLI
 
[https://devcenter.heroku.com/articles/heroku-cli#download-and-install](https://devcenter.heroku.com/articles/heroku-cli#download-and-install)

`$ heroku login`

## Step 3) Create Heroku App

```bash
$ heroku create --buildpack heroku/python
Creating app... done, thawing-hamlet-90035
https://thawing-hamlet-90035.herokuapp.com/ | https://git.heroku.com/thawing-hamlet-90035.git

$ git init
Initialized empty Git repository in <PATH>.git/

$ heroku git:remote -a thawing-hamlet-90035
set git remote heroku to https://git.heroku.com/thawing-hamlet-90035.git
```

## Step 4)

Define Procfile

```text
web: gunicorn app:app --log-file=-
```

Define requirements.txt

```text
Flask
Flask-HTTPAuth
gunicorn
```

## Step 5)

```bash
git add
git commit
git push heroku master
```

-----

## Notes:

**using the heroku cli**

```bash
$ heroku help
$ heroku apps                # list all apps
heroku logs                  # display logs for your app
heroku config:set KEY=VALUE  # set config variable
heroku config:get KEY        # get config variable
heroku config:unset KEY      # unset config variable
```

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Week 2 - HTTP, REST, URLs, APIs, Curl, UDP Multicast, Heroku, IPv6 vs IPv4

## Lab Objectives

In this lab you'll learn the following:

* Learn common IP protocols: HTTP, REST, URLs, and APIs
* Learn curl, a useful tool for APIs
* Use that knowledge with Quizical Flask Server
* The difference between IPv6 and IPv4
* How to multicast to a network
* How to create an application in the cloud using Heroku)


## Homework

Setup a free Heroku account for hosting your own IoT applications. Host Quizical and send
a link to me.


## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartA.md) Cryptographics  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartB.md) 
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartC.md) IPv4 vs IPv6, understand some issues with IPv6    
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/homework.md) Move Quizical to your own free Heroku account  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab7 Part A - Cryptographics 

In this section of the lab you will learn

* Hash functions and when to use them
* Encryption algorithms and when to use them
* Public-key algorithms and when to use them

We'll use the Rapsberry Pi for exploring cryptography.

## Step 1 - Install pycrypto

Install pycrypt on your Rapsberry Pi

Either: 

```
pi$ sudo apt-get install python-crypto
```

Or do: 

```
pi$ sudo apt-get install python2.7-dev
pi$ sudo pip install pycrypto
```

Verify installation worked

```
pi$ python
>>> from Crypto.Hash import SHA256
>>> hash = SHA256.new('Hello World').hexdigest()
>>> print 'hash len(' + str(len(hash) / 2) + ') ' + hash
```

## Step 2 - Hash Algorithms

This explores hashing by making a user/password file.

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab7/src
pi$ iotsha256.py
```

Try entering a few different users and passwords by pressing Enter (no name)
to create new users.

Try logging into each account by typing username and password.

Try logging in with the wrong password.

Let's examine the file passwords.txt.

Easy: guess the password for user 'hello'.

Bonus: See if you can determine the password for user "drew".


## Step 3 - Block Cipher (AES)

This lab uses MQTT to send/receive encrypted text.

This uses a global built-in key.

```
pi$ python mqtt_subscribe_aes.py
```

In another SSH terminal window on your Raspberry PI, run the MQTT
publish application. This requires you to enter a key

```
pi$ python mqtt_publish_aes.py secretkey
```

Publish some lines of text. Notice the text is encoded on sending,
and decoded on receiving at the Subscriber.

Try changing your key on the subscriber (by editing the mqtt_subscribe_aes.py).

Make sure to change the key on the cmdline for the publisher.

Note: the AES key must either by 16 bytes (AES-128) or 32 bytes (AES-256)


## Step 4 - Public Key (RSA)

```
pi$ python iotpki.py The quick brown fox jumped over the lazy dog.
```

## Step 5 - Signing a Public Key

Sign

Signing a message can be useful to check the author of a message and make
sure we can trust its origin. Next is an example on how to sign a message.
The hash for this message is calculated first and then passed to the
sign() method of the RSA key.

Start by running python from SSH on the Rapsberry Pi.

**Signing** 

```
$pi python
>>> from Crypto.Hash import SHA256
>>> from Crypto.PublicKey import RSA
>>> from Crypto import Random
>>> random_generator = Random.new().read
>>> key = RSA.generate(1024, random_generator)
>>> text = 'my_signature'
>>> hash = SHA256.new(text).digest()
>>> signature = key.sign(hash, '')
>>> public_key = key.publickey()
```

**Verify**

Knowing the public key, it is easy to verify a message. The plain text is sent
to the user along with the signature. The receiving side calculates the hash
value and then uses the public key verify() method to validate its origin.

```
>>> text = 'my_signature'
>>> hash = SHA256.new(text).digest()
>>> public_key.verify(hash, signature)
True

>>> text = 'not_my_signature'
>>> hash = SHA256.new(text).digest()
>>> public_key.verify(hash, signature)
False
```

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartA.md) Cryptographics  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartB.md) WPA2 and Access Points  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartC.md) TLS and self-signed certs  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab/homework.md) Move Quizical to your own free Heroku account  


[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

Lab2 Part B - Quizical, A more complicate API, with secure tokens

# Quizical

Quizical is a multiple-choice quiz engine using Python and Flask. It's
designed to instruct how APIs can be designed, and how to use all HTTP VERBs
in actual commands. It will later be used to host an application on the
internet.

Go to the GitLab Wiki to see the Quizzical documentation.

## Overview

The instructor will run Quizical on his machine for those working in the classroom. Everyone
on the local network should be able to participate.

If you are working remotely, or wish to run your own quiz, run quizzical yourself (it can
run in the raspberry PI). See Remote Instructions.


## Quiz Client

Open another terminal window for the Client application, quiz.py

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab2/src
pi$ python quiz.py
```

You should log in with your firstname, last initial, and your lastname as your password. For
example, if your name is matt smith, your username is `matts` and your password is `smith`.

```
Enter Username (e.g. me): me
Enter Password (e.g. pass): pass
token=smUG5gJ83hxiOgQFRXv5

Quiz: osi7layer question: 1
What best describes the PHY layer?
 A. It is the physical modulation layer (e.g. wireless or wired)
 B. It is for medical (physician) devices
 C. It is for signal quality (fidelity)
 D. It is the study of plants (phytology)
Your answer: A

Wait for your instructor to post the next question
```

Make sure wait after posting each answer, otherwise, the quiz will stop. This isn't a rich UI
quiz engine, just a simple demonstration.

# Remote Instructions

In one terminal window run the Quizical Server.

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab2/src
pi$ python quizical.py
```

If you want to move on to the next question, you must act as your own instructor. Use
curl to do this in yet another terminal window: Copy the token into to use with curl.

```
pi$ curl localhost:5000/api/v1/login/drewg?pwd=gislason
pi$ curl localhost:5000/api/v1/teacher/quiz?token=smUG5gJ83hxiOgQFRXvF -X PUT \
-d '{"question":"2","answer":"C"}'
```

To end the quiz, use {"name":"done"} for the data.

To see quiz results for all students, use:

```
$pi curl localhost:5000/api/v1/teacher/results?token=smUG5gJ83hxiOgQFRXvF
```

FYI, `localhost` and `127.0.0.1` are the same.


## Try Making Your own Quiz or adding your own users

Modify quizical.py to contain your own multiple choice quiz.

For now, you'll need to modify the quizical.py program. However, the API could
be extended to POST new quizzes and to add/remove users.

Host quizical on your own PI (see instructions for remote use), and try out your
quiz.


[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

Lab2 Part B - IPv6 vs IPv4

# Use ifconfig to find out your 

```
$pi ifconfig | grep inet

  inet 127.0.0.1 netmask 0xff000000 
  inet6 ::1 prefixlen 128 
  inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 
  inet6 fe80::494:eaba:18ea:2955%en0 prefixlen 64 secured scopeid 0x4 
  inet 172.27.40.103 netmask 0xffffff00 broadcast 172.27.40.255
  inet6 fc00:1::c38:b3d9:1366:80a2 prefixlen 64 autoconf secured 
  inet6 fc00:1::75b2:dd8:f250:2de9 prefixlen 64 autoconf temporary 
  inet6 fc00:1::d932 prefixlen 64 dynamic 
  inet6 fe80::3072:afff:febc:95b1%awdl0 prefixlen 64 scopeid 0x8 
  inet6 fe80::68e4:5bb7:4b84:cd5f%utun0 prefixlen 64 scopeid 0xa 
  inet6 fe80::5b8e:9097:223c:7003%utun1 prefixlen 64 scopeid 0xb 
```

# Printing Routes

  Windows: route print

  MAC / Linux: netstat -nr


# IPv6 client and server

This lab is very simple. Take a look at the ipv6client.py and ipv6server.py

In a terminal window, run

```
$pi cd ~/Documents/Git/iot-210B-student/Lab2/src
$pi python ipv6server.py
```

In another terminal window, run

```
$pi cd ~/Documents/Git/iot-210B-student/Lab2/src
$pi python ipv6client.py
```

# Experiments

Try sending data to another server in the same classroom (on the same subnet).

Try sending data to another server across the internet (elsewhere)

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

Lab2 Part D - Multicast

Note: If working remotely, you will want to have a terminal on your PC, or have two
Raspberry Pi devices on your same Wi-Fi (or wired) network.

Broadcasts do not go to yourself.


# Step 1 - Setup UDP Server

Open an SSH Terminal into the RPi3. Run the UDP server.

```
$pi cd ~/Documents/Git/iot-210B-student/Lab2/src
$pi python ipv4_udp_server.py
```

# Step 2 - Find Multicast Address on your RPi3

Look for the Bcast interface. This isn't really a broadcast,
but a multicast on your subnet. (e.g. 172.22.194.255)

```
$pi ifconfig | grep inet
```

# Step 3 - Run UDP Client

**Open another SSH terminal** into your RPi3.

Modify the UDP client default address to broadcast. Important,
You must also modify the socket options to allow broadcasting.


Try sending messages to each other unicast (e.g. to iot40a2.local) and broadcast to all in the room


[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
# Quizical Documentation

Quizical is an easy to use quiz API.


## APIs

Verb   | API                             | Description
------ | ------------------------------- | --------------------------------------------------------
GET    | /api/v1/login/{name}            | Login to Quizical. Receive a token for subsequent calls.
PUT    | /api/v1/profile                 | Used to change user password. Requires the login token.
GET    | /api/v1/student/question        | Get the current question with possible answers.
GET    | /api/v1/student/answer          | Your quiz results so far.
PUT    | /api/v1/student/answer          | Answer a question. Write once.
GET    | /api/v1/teacher/quiz            | Get the current quiz
PUT    | /api/v1/teacher/quiz            | Start a new quiz, move quiz on to next question, etc...
POST   | /api/v1/teacher/quiz            | Create a new quiz (clears all student answers)
DELETE | /api/v1/teacher/quiz            | Delete a quiz by name
GET    | /api/v1/teacher/results         | Results for all students
GET    | /api/v1/teacher/admin           | Get the list of students
POST   | /api/v1/teacher/admin           | Post a list of students


## CURL Script Examples

Curl is a general purpose tool. Below are the important bits.

```
  curl http://vcabin.swiftwater.lab/api/v1/student/{name}/question \
    -X verb \
    -H "Content-Type: application/json" \
    –d 'data'
    --verbose
```
It's available by default on the Mac (in the Terminal app), and in Windows via Cygwin or the Windows 10 Bash shell.

The --verbose is not needed, but can help understand HTTP, and can be useful for debugging.

The `Content-Type: application/json` header is not needed, as quizical.py assumes JSON.

For all examples below, the student is named "me" and the password "pass", and the login token is "xxxx".

The quizical.py application is assumed to be hosted at `https://frozen-castle-53348.herokuapp.com` (port 443).

### /api/v1/login/{name}

**Methods: GET**

Login to Quizical. Receive a token for subsequent calls

```
curl https://frozen-castle-53348.herokuapp.com/api/v1/login/me?pwd=pass
```

Returns a token, in JSON form, that must be used on all subsequent calls as a parameter.

```
{"token":"xxxx"}
```

If either the username or password is wrong, a `403 Forbidden` is returned.

### /api/v1/profile

**Methods: PUT**

Used to change user password. Requires the login token.

```
curl https://frozen-castle-53348.herokuapp.com/api/v1/profile?token=xxxx -X PUT -d '{"newpwd":"pass"}'
```


### /api/v1/student/question

**Methods: GET**

Get the current question with possible answers.

```
curl https://frozen-castle-53348.herokuapp.com/api/v1/student/question?token=xxxx
```

Returns the current quiz name and question, with all possible answers.

```
{"quizname":{"1":[ "ques"," a1"," a2"," a3"," a4" ]}}
```


### /api/v1/student/answer

**Methods: GET, PUT**

Returns your quiz results so far (GET), or allows a question to be answered (PUT).

Note: Each question can only be answered once (that is, if you PUT a second time it will return with the
answer unchanged).

```
# get answers so far
curl https://frozen-castle-53348.herokuapp.com/api/v1/student/answer?token=xxxx

# Answer question 2 with multiple choice 'D'
curl https://frozen-castle-53348.herokuapp.com/api/v1/student/answer?token=xxxx -X PUT -d '{"2":"D"}'
```

Returns `200 OK` and the following JSON:

```
{"correct":True,"results":"1/4","answers":{"1":"B","2":"D"}}
```

In the results above, the student has gotten one answer right out of 4.

If token is not valid, then returns `403 Forbidden`.


### /api/v1/teacher/quiz

**Methods: GET, PUT, POST, DELETE**

This API allows the teacher to view (GET), create (POST), start/continue (PUT) and delete (DELETE) quizzes.

```
# get the current quiz
curl https://frozen-castle-53348.herokuapp.com/api/v1/teacher/quiz?token=xxxx

# create a new quiz
curl https://frozen-castle-53348.herokuapp.com/api/v1/teacher/quiz?token=xxxx -X POST \
-d '{"python":{"questions":{"1":["ques"," A", "*B"],"2":["ques","*A"," B"]}}}'

# start the quiz
curl https://frozen-castle-53348.herokuapp.com/api/v1/teacher/quiz?token=xxxx -X PUT -d '{"name":"python","question":"1","answer":"B","reset":true}'

# go to question 2 in quiz
curl https://frozen-castle-53348.herokuapp.com/api/v1/teacher/quiz?token=xxxx -X PUT -d '{"question":"2","answer":"D"}'

# delete a quiz
curl https://frozen-castle-53348.herokuapp.com/api/v1/teacher/quiz?token=xxxx -X DELETE -d '{"name":"python"}'
```

A quiz is defined by a unique name and a set of questions. Each question is an array, where element 0 is the
question, and all other elements are the answers. The 1st character of each answer must either be a space (for
incorrect answer) or with a '*' to indicate correct answer.

The '*' is removed (so the student doesn't know the correct answer) when viewing the question through the
`/api/v1/student/question` interface.

Returns 400 Bad Request if the quiz is not in the proper form.

### /api/v1/teacher/results

**Methods: GET**

This API allows the teacher to retrieve results of the quiz for all students. The option `anon`
allows the student names to be anonymous.

```
curl https://frozen-castle-53348.herokuapp.com/api/v1/teacher/results?token=xxxx?anon=1
```
{
  "drewg": { "results":"4/4", "answers":{"1":"A","2":"C","3":"D","4":"C"}}
}

### /api/v1/teacher/admin

**Methods: GET**

Get the list of students (GET) or post a list of students (POST)

```
# get the list of students
curl https://frozen-castle-53348.herokuapp.com/api/v1/teacher/admin?token=xxxx

# post a new list of students
curl https://frozen-castle-53348.herokuapp.com/api/v1/teacher/quiz?token=xxxx -X POST \
-d '{"name1":{"pwd":"pass","access":0,"token":"-","answers":"-"}}'
```

Returns JSON list of students.

```
{"name1":{"pwd":"pass","access":0,"token":"-","results":"-","answers":{}}}
```

Returns 400 Bad Request if student list is not in the proper form.
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Homework

The homework is to install the Texas Instruments ZigBee Software on your
Microsoft **Windows** laptop. If you run macOS or Linux, you'll need to
install a Windows virtual machine.

Many of the embedded tools run on Windows only (some only on older versions
such as Window 7 or even Windows XP). All the tools we use in class should
run on Windows 10 just fine.

# Step 1 - Hardware - CC2650 LaunchPad

You'll need at least one Texas Instruments CC2650 Launchpad. If working
remotely, get 2.

I recommend you order from DigiKey (as you can get it in a couple of days or less).

https://www.digikey.com/en/product-highlight/t/texas-instruments/launchxl-cc2650-launchpad-kit

See also: http://www.ti.com/tool/launchxl-cc2650

**Optionally** get an 802.15.4 Sniffer (to watch packets).

http://www.ti.com/tool/cc2531emk

Digi-Key has it labled wrong (RFID rather that 802.15.4), but this is a sniffer: 

https://www.digikey.com/product-detail/en/texas-instruments/CC2531EMK/296-28921-ND/2231688


# Step 2 - Download the SimpleLink App in your Phone

If you have a smart phone (Android or Apple), you can Download
the Texas Instruments `Simplelink Starter` app from Apple App
Store or Google Play.

If you have the CC2650 LaunchPad hardware, you can verify it all
works, as it has a Bluetooth application ready to go out-of-box.

1. Plug LaunchPad into power (you can use one of your USB chargers or your laptop
2. Launch the SimpleLink Starter app
3. Press (and hold!) the BTN-2 button on the LaunchPad
4. Select the LaunchPad from the menu of Bluetooth Smart Devices
5. Select Mission Control
6. Turn on/off LEDs
7. Try out buttons (it will indicate on screen the state of BTN-1 and 2


# Step 3 - Download and Install Texas Instruments Software

http://processors.wiki.ti.com/index.php/CC2650_LaunchPad_User%27s_Guide_for_ZigBee

Follow the instructions down to and including the "Software" heading,
including downloading and installing

* Z-Stack Home 1.2.2a SDK
* TI-RTOS for SimpleLink Wireless MCUs
* IAR for ARM (EWARM) Embedded WorkBench ARM (see IAR below)

We'll be going through the "Porting Z-Stack Home) and setting up
the actual LaunchPad boards with ZigBee programs in class.

# Step 4 - Download and Install IAR

IAR (https://www.iar.com) Embedded WorkBench for ARM is a C compiler
and debugging environment. ARM processors for ZigBee, Thread and
Bluetooth are very popular and IAR EWARM is supported by NXP, TI,
SiLabs and others.

If you already have **IAR 7.40.2 for ARM** or later installed on
your Windows machine, you are fine.

IAR has a 30-day free trial. If you've already used a 30-day trial and can't
install it, call IAR and explain your are taking the UW IoT 210 course and
they should give you another 30-day free trial.

https://www.iar.com/iar-embedded-workbench/#!?currentTab=free-trials

Do NOT install the KickStart size-limited version, as it cannot build
the ZigBee programs. Choose the 30-day time-limited version instead.

# Step 5 - Download and Install Ubiqua Protocol Analyzer

If you got the Sniffer, or want to analyze packets, you can
use the following software.

www.ubilogix.com

Download 30-Day free trial




[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Week 3 - Google Protobufs, JSON vs XML, Schemas, SSE vs Websockets, MQTT with MQTT-SN, 

## Lab Objectives

In this lab you'll learn:

* How to add Google protobufs into Python, how to create .proto files and use them in applications.
* The difference between JSON and XML.
* How to use JSON and XML schemas.
* How to use Websockets and SSE.
* How to connect an MQTT-SN broker to an MQTT broker to support lossy networks.


## Homework

Set up an account and install ZigBee Home Automation 1.2 from www.ti.com. 

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab3/LabPartA.md) Google Protobufs and how to use them  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab3/LabPartB.md) JSON,XML and Schemas  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab3/LabPartC.md) WebSockets and SSE  
[PART D](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab3/LabPartD.md) MQTT and MQTT-SN  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab2/homework.md) Install ZigBee Home Automation 1.2  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab3 Part A - Google Protobufs and How to Use Them

Total Lab Time: 45 minutes

In this section of the lab you will

* Learn what Google protobufs are, and when to use them
* Learn what a .proto file is, and how to design one
* How to install Google protobufs on the Pi for Python
* Take the quiz using protobufs (instead of JSON)

## Some Useful Protobuf Links

**Tutorials**  
https://developers.google.com/protocol-buffers/
https://developers.google.com/protocol-buffers/docs/pythontutorial

**Source**  
https://github.com/google/protobuf
https://github.com/google/protobuf/releases

## Step1 - Verify you have enough disk space (you'll need about 2G free)

Open a terminal window on your RPi3 with ssh. Then check disk space.

```
$pi df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/root        59G  4.2G   52G   8% /
devtmpfs        459M     0  459M   0% /dev
tmpfs           463M     0  463M   0% /dev/shm
tmpfs           463M  6.3M  457M   2% /run
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           463M     0  463M   0% /sys/fs/cgroup
/dev/mmcblk0p1   63M   21M   43M  34% /boot
tmpfs            93M     0   93M   0% /run/user/1000
```

Make sure you have at least 2G Avail on /dev/root.

## Step 2 - Install Google Protobufs 3.2 on your Raspberry Pi

Open another ssh terminal into the RPi3.

A release file from `https://github.com/google/protobuf/releases`
is already in the git project. Make sure to pull the latest.

Then, unzip that project into a new folder.

```
pi$ cd ~/Documents/Git/iot-210B-student
pi$ git pull
pi$ cd ~/Documents
pi$ unzip Git/iot-210B-student/Lab3/src/protobuf-3.2.0.zip
pi$ ls protobuf-3.2.0
```
You should see many files/folders in folder `protobuf-3.2.0`.


## Step 3 - Install the tools needed to build protobufs

The RPi3 by default doesn't have autoconf, automake or libtool installed.
Install those.

```
pi$ sudo apt-get update
pi$ sudo apt-get install autoconf automake libtool
```

# Step 4 - Building protoc

The configure is fairly fast.

The **make takes a REALLY LONG TIME** on the RPi. It took 7 minutes on my MAC. It
took over 45 minutes on my Pi. We'll stop here and wait for it to complete. While
we're waiting, more lecture!

```
pi$ cd ~/Documents/protobuf-3.2.0
pi$ ./configure
pi$ make
```

# Step 5 - Installing protoc

Once done making, then install protoc.

```
pi$ sudo make install
pi$ sudo ldconfig # refresh shared library cache.
pi$ protoc --version
    libprotoc 3.2.0 
```

# Step 6 - Add Protobufs to Python

Next, you need to add protobufs to your python folders. This should take
about 3 minutes.

```
pi$ cd ~/Documents/protobuf-3.2.0/python
pi$ python setup.py build
pi$ python setup.py test
pi$ sudo python setup.py install
```

# Step 7 - Running the Address Book Application

Now that everything is installed, you can actually use protobufs in your RPi3.

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab3/src
pi$ python list_people.py book
Person ID: 1
  Name: Drew
  E-mail address: drewg@rockisland.com
  Home phone #: 555-1212
Person ID: 2
  Name: Alicia Gislason
  E-mail address: alicigislason@icloud.com
  Work phone #: 444-2222
```

Or try adding an entry

```
pi$ python add_person.py book
```

# Step 8 - Try Creating a Protobuf Program from Scratch

The following simple.proto file defines a single integer. 

```
syntax = "proto3";
message Test1 {
  int32 a = 1;
}
```

The program simple.py won't run until a file called "simple_pb2.py" is
created.

```
pi$ python simple.py
```

Notice it fails to run (can't import simple_pb2.py). Now, compile the
simple.proto file into a python module.

```
pi$ protoc --python_out=. simple.proto
pi$ python simple.py
    Enter number: 150
    created 'simple.bin'
```

Use hexdump to display the binary file `simple.bin`. If you set
`Test1.a = 150`, should be the bytes `08 96 01`.

```
hexdump simple.bin
```

Try running the program and entering other values. Try changing the
messgage Test1 in 'simple.proto' and modifying the Python program to
enter other things.

Next Lab:  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab3/LabPartB.md) Lab3 Part B - JSON, XML and Schemas

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab3 Part B - JSON, XML and Schemas

In this section of the lab you will create a Flask API that can take
protobufs, XML or JSON as input and output.

* Learn to convert between JSON and XML
* Learn to use a schema
* Learn how to handle JSON, XML and Protobufs in one Flask API
* Learn base64

# Step 1 - JSON, XML Protobuf Protocols

Examine the files `book.json`, `book.xml` and `book`. All three
files contain the same data encoded with different protocols.

* book.json - JSON format of address book
* book.xml - XML format of address book
* book - protobufs format of address book

```
cd ~/Documents/Git/iot-210B-student/Lab3/src
pi$ more book.json
pi$ more book.xml
pi$ hexdump book
```

# Step 2 - On-Line Validating

The following links define the JSON, XML and Protobug protocols.

http://www.json.org  
https://www.w3schools.com/xml/
https://developers.google.com/protocol-buffers/docs/pythontutorial
https://developers.google.com/protocol-buffers/docs/proto3

The following links allow you to validate data.

http://www.freeformatter.com/xml-validator-xsd.html  
http://jsonlint.com  
http://yura415.github.io/js-protobuf-encode-decode/  

Try creating some of your own JSON, XML and Protobuf Message files.

# Step 2 - Schemas

A Schema validates the content of your message, to make sure the
correct fields are present and the data is in the proper form.

Use the JSON file `person.json' and validate it against the schema
`person.jsd` in the online formatter below.

Use the XML file `order.xml` and validate it against the schema
`order.xsd`.

https://jsonschemalint.com/#/version/draft-04/markup/json
http://www.freeformatter.com/xml-validator-xsd.html  

There is no "schema" for protobufs that I'm aware of.

Try making modifications to the schema or the data. Make it wrong
and see if the validators catch it.


# Step 3 - Run multi_server, a Multiple Protocol Server

The python program `multi_server` can serve up JSON, XML and Protobuf
formatted data.

**API:**  
See simple.proto  

VERB | Route | Description | Data
---- | ----- | ----------- | ----
GET | /api/v1/simple | Get current number in (defaults to JSON format) | '{"number":3}'
PUT | /api/v1/simple | Set current number in (defaults to JSON format) | '{"number":3}'

In one terminal window on RPi3, run the multiple protocol server `multi_server.py`.

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab3/src
pi$ python multi_server.py
```

In another terminal window on the RPi3 or your PC, try sending data in various forms.

Examples of payloads to the multiple protocol server.

```
// get current number
pi$ curl 127.1:5000/api/v1/simple

// set current number to 23
pi$ curl 127.1:5000/api/v1/simple -X 'PUT' -d '{"number":23}' -H 'Content-Type: application/json' --verbose

// set current number to 53 in XML
pi$ curl 127.1:5000/api/v1/simple -X 'PUT' -d '<number>53</number>' -H 'Content-Type: application/xml' --verbose

// set current number to 150 in Protobufs
pi$ curl 127.1:5000/api/v1/simple -X 'PUT' -d 'CJYB' -H 'Content-Type: application/protobuf' --verbose
```

# Step 4 - Base64

Base64 is an ASCII text represenation of binary data. It uses 64 ASCII character
(a-z,A-Z,0-9,+/) to encode the binary data. The resulting data is 33% larger,
but can be transmitted/parsed by ASCII protocols such as HTTP.

You can manually create a base64 representation of a protobuf Test1.a number by
doing the following in Python Idle.

```
pi$ python
import base64
str = '\x00\x11\x22\xfe'
str
data = base64.b64encode(str)
data
```

Protobufs is binary protocol. The following example assumes you've created
the simple_pb2.py from LabPartA.

```
pi$ python
import base64
import simple_pb2
myvar = simple_pb2.Test1()
myvar.a = 150
str = myvar.SerializeToString()
str
data = base64.b64encode(str)
data
```

Next Lab:  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab3/LabPartC.md) Lab3 Part C - WebSockets and Server Sent Events

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab3 Part C - WebSockets and Server Sent Events

In this section, you'll learn

* How to use WebSockets
* How to use SSE

git clone https://github.com/websocket-client/websocket-client

# Step 1 - Install Webcosket

See: https://github.com/websocket-client/websocket-client

Open a terminal window into the Pi3 and install the websocket-client

```
pi$ cd ~/Documents
pi$ git clone https://github.com/websocket-client/websocket-client.git
pi$ cd websocket-client
pi$ sudo python setup.py install
```

Note: on my Mac, I apparently had a different websocket client installed
for Python. So I ended up downloading this package and using git clone.


# Step 2 - Use a WebSocket Client

A convenient WebSocket server is at `ws://echo.websocket.org/`

From the open terminal window on the Pi.

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab3/src
pi$ ws_client.py
```

# Step 3 - SSE

Below is a curl script that will work with an SSE Client. However, I
wasn't able to find an on-line SSE Server (and didn't make one).

The `http_client.py` can easily be modified to perform the SSE client
functionality (just an added header, and keep open the socket).

I'll leave task to the student (optional).

```
pi$ curl host_ip/path/to/sse -H 'Accept: text/event-stream'
```

You can see one that works in your browser at:
`http://demo.howopensource.com/sse/`

You can also install flask-sse. I did not think we would have time to
install this and get it running with the other topics this lab.

See `https://pypi.python.org/pypi/Flask-SSE`


Next Lab:  
[PART D](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab3/LabPartD.md) Lab3 Part D - MQTT and MQTT-SN

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab3 Part D - MQTT and MQTT-SN

In this section, you'll learn

* About the MQTT and MQTT-SN protocols
* How to access MQTT from the Web and from Python Applications

# Step 1 - Try out HiveMQ

MQTT is a widely adopted protocol (AWS uses it for example). A variety
of companies make MQTT broker and client (publisher and subscriber)
software.

HiveMQ is an online MQTT Broker that is enterprise quality.

1. Open a web browser to `http://www.hivemq.com/try-out/`
2. Click on the `Try the websocket client`
3. Pick a username/password
4. Set Keep Alive time to 300 (5 minutes) and Connect
5. You should see Topic `testtopic/1`
6. Add a subscription to `testtopic/1`
7. Type in a Message and Publish it
8. Let's all add a subscription to topic `iot210`
9. Type in Messages and Publish them to topic `iot210`

# Step 2 - Install Paho Python Client MQTT

```
pi$ sudo pip install pah-mqtt
```

Then, open 2 terminal windows on the Raspberry Pi, one for the publisher,
one for the subscriber (both of which are clients of a broker at iot.eclipse.org):

In the 1st terminal window, run the publisher

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab3/src
pi$ python mqtt_publish.py
```

In the 2nd terminal window, run the subscriber

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab3/src
pi$ python mqtt_publish.py
```

Try sending various messages to the iot210 group. Notice, we now have a
group chat.

# Step 3 - Extend the program

See if you can extend the program to allow topic: to go to a specific topic
to allow for individual or other group chats.

Example

```
Enter topic: string to post to individuals or other groups
```

# Step 4 - MQTT-SN

We'll learn about this in lecuture, but will implement during the ZigBee
or more embedded portion.


[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Homework for Week 4

A number of people didn't have the right software installed, or have the
correct hardware at Week for, so I've included more complete instructions below
and we'll try again for Week 5.

Week 4 Homework (in preparation for Week 5) is to install the following software,

The software (Texas Instruments ZigBee Stack, IAR Embedded WorkBench for ARM, and Ubilogix Ubiqua)
all require Windows at this point.

For those of you with only a MAC computer, or Linux, you can follow along with the class.

I do not currently have instructions for TI Code Composer Studio 6.x at this time.

* The primary thing in this class is to learn ZigBee
* The secondary thing is to learn about TI and their tools


# Step 1 - Hardware - CC2650 LaunchPad

You'll need at least one Texas Instruments CC2650 Launchpad. If working
remotely, get 2.

**I recommend you order from DigiKey** (as you can get it in a couple of days or less).

https://www.digikey.com/en/product-highlight/t/texas-instruments/launchxl-cc2650-launchpad-kit

See also: http://www.ti.com/tool/launchxl-cc2650

**Optionally** get an 802.15.4 Sniffer (to watch packets).

http://www.ti.com/tool/cc2531emk

Digi-Key has it labled wrong (RFID rather that 802.15.4), but this is a sniffer: 

https://www.digikey.com/product-detail/en/texas-instruments/CC2531EMK/296-28921-ND/2231688

The Optional HW is useful to examine over-the-air packets. The sniffer is used
with Protocol Analyzers such as WireShark or Ubilogix Ubiqua.


# Step 2 - Download the SimpleLink App in your Phone

If you have a smart phone (Android or Apple), you can Download
the Texas Instruments `Simplelink Starter` app from Apple App
Store or Google Play.

If you have the CC2650 LaunchPad hardware, you can verify it all
works, as it has a Bluetooth application ready to go out-of-box.

1. Plug LaunchPad into power (you can use one of your USB chargers or your laptop
2. Launch the SimpleLink Starter app
3. Press (and hold!) the BTN-2 button on the LaunchPad
4. Select the LaunchPad from the menu of Bluetooth Smart Devices
5. Select Mission Control
6. Turn on/off LEDs
7. Try out buttons (it will indicate on screen the state of BTN-1 and 2

Some people said they had trouble with the Android App, but iOS worked fine.

# Step 3 - Download and Install Texas Instruments Software

You'll need to sign up for a free TI account.

http://processors.wiki.ti.com/index.php/CC2650_LaunchPad_User%27s_Guide_for_ZigBee

Follow the instructions down to and including the "Software" heading,
including downloading and installing

* Z-Stack Home 1.2.2a SDK
* TI-RTOS for SimpleLink Wireless MCUs

We'll be going through the "Porting Z-Stack Home) and setting up
the actual LaunchPad boards with ZigBee programs in class.

Make sure to download **version 2.21.00.06 of the TI-RTOS** and drivers for the CC2650.
Download that exact version to have the same results as I do in class.

[Download Z-Stack Home 1.2.2a](http://www.ti.com/tool/z-stack-archive)
[Download TI-RTOS for SimpleLink Wireless MCUs](http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/mcusdk/index.html)


# Step 4 - Download and Install IAR

IAR (https://www.iar.com) Embedded WorkBench for ARM is a C compiler
and debugging environment. ARM processors for ZigBee, Thread and
Bluetooth are very popular and IAR EWARM is supported by NXP, TI,
SiLabs and others.

If you already have **IAR 7.40.2 for ARM** or later installed on
your Windows machine, you are fine.

IAR has a 30-day free trial. If you've already used a 30-day trial and can't
install it, call IAR and explain your are taking the UW IoT 210 course and
they should give you another 30-day free trial.

https://www.iar.com/iar-embedded-workbench/#!?currentTab=free-trials

Do NOT install the KickStart size-limited version, as it cannot build
the ZigBee programs. Choose the 30-day time-limited version instead.

# Step 5 - Download and Install Ubiqua Protocol Analyzer

Sign up for a free Ubilogix accunt.

Install the following Ubilogix Ubiqua software. It can be used to analyze
packets.

If you did not get the TI sniffer, do not worry, you can analyze packets from
a file. The sniffer is only needed to record data packets, not play them back.

[Ubilogix Ubiqua Free Trial](https://www.ubilogix.com/ubiqua#trial)
[Ubilogix Main Site](www.ubilogix.com)


[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Week 4 - ZigBee Part1 

## Lab Objectives

In this lab you'll learn:

* What ZigBee is, and what problem space it solves
* What tools are used to build ZigBee Applications
* How build a ZigBee Application for the TI CC2650
* How to build a ZigBee network

## Homework

None (other than completing the labs we do in class)

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab4/LabPartA.md) ZigBee Light
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab4/LabPartB.md) ZigBee Network
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab4/homework.md) Finish Lab Work  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab4 Part A - A First ZigBee Application - Sample OnOff Switch

Total Lab Time: 1 hour

In this section of the lab you will learn

* How to use IAR Ebedded Workbench for ARM
* Learn about the TI ZigBee Stack, and how to port it to the 2650 Launchpad
* Examine the ZigBee OnOff Switch Application

You will need a Windows computer (version 7 or later, preferably version 10, 32-bit or 64-bit)
for this lab.

This lab assumes the tools are already installed. Tools used in this lab:

* TI ZigBee Stack and RTOS
* IAR EWARM 30-day eval (or standard version). Do NOT use the Kickstarter, as this won't build the ZigBee images.

See [Lab 3 Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab3/homework.md) for how to install the tools on Windows.

# Step 1 - Exploring IAR Embedded Workbench for ARM

Note: IAR moves projects are not backward compatible: once a project is opened with a new version
of IAR, it can't be opened with a previous version.

The TI software compiles without error or warning and was tested with IAR 7.4, but other versions (such as
the current 8.11


# Step 2 - Porting Z-Stack Home 1.2.2a to the CC2650 LaunchPad


See http://processors.wiki.ti.com/index.php/CC2650_LaunchPad_User%27s_Guide_for_ZigBee

**Important:** The use SampleLight (not SampleSwitch) as the base project, since a
Light is functional all on it's own (without a network).

BTN-1 will toggle the light if we are successful.

Note: This will be a ZigBee Coordinator (project type selectable in IAR)

We'll also set the -DDEFAULT_CHANLIST and -DZDAPP_CONFIG_PAN_ID in
Tools/f8wConfig.cfg so we don't interfere with each other during class.

Start following instructions "Porting Z-Stack Home 1.2.2a to the CC2650 LaunchPad" in class

# Step 3 - Programming the CC2650 Launchpad

When programming devices for the first time, the entire Flash memory should be erased:
select "Project->Download->Erase Memory" in IAR.


Next Lab:  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab4/LabPartB.md) Lab4 Part B ZigBee Switch

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab4 Part B - First ZigBee Network - Light and Switch

Total Lab Time: 30 minutes

In this section of the lab you will

* Go through the process of porting a ZigBee Application from 1 board to another
* Examine the ZigBee OnOff Light Application

# Step 1 - Same Steps, but for Switch

This assumes you've completed Part A

Now, do the same instructions, but use the SampleSwitch.

The Sample Switch will be a ZigBee Router (later we can do an end-device) 

In IAR, use the same settings in Tools/f8wConfig.cfg for 
the -DDEFAULT_CHANLIST and -DZDAPP_CONFIG_PAN_ID


[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Homework for Week 5

Next week, we'll explore Bluetooth Low Energy (aka Bluetooth Smart)

Install the BLE stack from Texas Instruments BLE-STACK-2-2-1 for the CC2650:

http://www.ti.com/tool/ble-stack

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/LabPartA.md) ZigBee Network Demonstrated  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/LabPartB.md) Use Ubiqua Protocol Analyzer  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/homework.md) Install Texas Instruments Bluetooth Low Energy Stack  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Week 5 - ZigBee Part 2

## Lab Objectives

In this lab you'll learn:

* How to form a ZigBee Network
* How to commission a new node and join a ZigBee Network using EZ-Mode
* How to capture ZigBee over-the-air (OTA) packets
* How to decode ZigBee packets
* ZigBee Security (including AES 128-bit)

## Homework

Install the Texas Instruments Bluetooth stack

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/LabPartA.md) ZigBee Network Demonstrated  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/LabPartB.md) Use Ubiqua Protocol Analyzer  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/homework.md) Install Texas Instruments Bluetooth Low Energy Stack  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab4 Part A - A ZigBee Network

In this section of the lab, you'll learn

* How easy compiling SHOULD be
* How to form a ZigBee Network
* How to commission a new node and join a ZigBee Network using EZ-Mode

# Step 1 - Installing Tools

Install the Texas Instruments Flash-Programmer-2 (I download version 1.7.5).

http://www.ti.com/tool/launchxl-cc2650
http://www.ti.com/tool/flash-programmer


# Step 1 - Compiling

Compiling ZigBee Applications for the CC2538, using JTAG to download code.

1. Open IAR
2. Go to File/Open/Workspace
3. Navigate to C:\TI\Z-Stack Home 1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2538
4. Open the .eww
5. Press F7 to compile the project
6. Done!
7. In Workspace, examine file Application/zcl_samplesw.c
8. In Workspace, examine file Tools/f8wConfig.cfg

Note: the .eww and .ewp are XML files that can be edited. Don't do this unless you back up
and are VERY careful. We do it to change paths sometimes (fater than add/files in IAR).

The TI software compiles without error or warning and was tested with IAR EWARM 7.4,
but other versions (such as the current 8.11.1) may cause warnings or issues. If
you have paid for a license, you get access to MyIAR, which allows downloading
older versions.


# Step 2 - Forming a 2-Node Network

Note: If you have a sniffer, and are in class, you can capture the Over-the-Air
data at

```
Pan ID: 0xd6d6
Channel: 11
```

1. Turn on the ZigBee Coordinator / OnOffLight
2. Turn on ZigBee End Device / OnOffSwitch
3. Press SW2 on ZC
4. Press SW2 on ZED
5. In a few moments they will be connected.
6. Press SW1 on ZED to toggle light on ZC


[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/LabPartA.md) ZigBee Network Demonstrated  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/LabPartB.md) Use Ubiqua Protocol Analyzer  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/homework.md) Install Texas Instruments Bluetooth Low Energy Stack  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab5 Part B - Decoding with Ubiqua

In this section of the lab, you'll learn 

* How to capture ZigBee over-the-air (OTA) packets
* How to decode ZigBee packets
* ZigBee Security (including AES 128-bit)

You will need a Windows PC (or Virtual Machine) to run Ubiqua.

# Step 1 - Exploring Ubiqua

Copy the file from Lab5 to you Windows PC.

1. Run Ubiqua
2. From File Menu run File/Open and choose "EZ-Mode Commissioning.cubx"
3. We'll examine the packets in this file in detail


For exploring AES-128, go to:

http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf


[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/LabPartA.md) ZigBee Network Demonstrated  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/LabPartB.md) Use Ubiqua Protocol Analyzer  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab5/homework.md) Install Texas Instruments Bluetooth Low Energy Stack  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Homework for Week 6

Go to side wolfssl.com, explore their offerings (all open source)

https://wolfssl.com/wolfSSL/Home.html

Download wolfssl-3.11.0.zip (see Download tab)

We'll use this next week to explore concepts like PKI

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartA.md) ZigBee Routing  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Beacons  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Profiles  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/homework.md) Install Wolf-SSL tools  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Week 6 - ZigBee, Bluetooth Low Energy, and 6LoWPAN (Thread)

## Lab Objectives

In this lab you'll learn:

* How to program your TI LaunchPad CC2650 for ZigBee Communications
* What Bluetooth Beacons are and how to make them on your Raspberry PI
* What 6LoWPAN and Thread are
* How to program your TI LaunchPad CC2650 for BLE Communications
* Sample tutorial, LauncPad

## Homework

Install Wolf-SSL Security tools.

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartA.md) ZigBee Routing  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Profiles  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Beacons  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/homework.md) Install Wolf-SSL tools  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab6 Part A - ZigBee Routing

In this section of the lab, you'll learn

* How to program the CC2650 for ZigBee (with an HA On-Off Switch)
* How to commission a new node and join a ZigBee Network using EZ-Mode
* Explore ZigBee Routing

# Step 2 - Examining the ZigBeeRouting.cubx

To see routing in action, open the ZigBeeRouting.cubx file

https://gitlab.com/Gislason/iot-210B-student/blob/master/Lab6/files/ZigBeeRouting.cubx


# Step 1 - Install the SmartRF Flash Programmer2

The SmartRF Flash Programmer 2 tool installs on your **Windows Laptop**.

http://www.ti.com/tool/flash-programmer

Make sure to install FLASH-PROGRAMMER-2:


# Step 2 - Flashing the CC2650 Board

Two .hex files have been prepared for you:

* [ZStackCoreEndDevice.hex](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/files/ZStackCoreEndDevice.hex)
* [SampleSwitch.hex](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/files/SampleSwitch.hex)

The ZStackCoreEndDevice.hex file is the ZigBee stack.

The SampleSwitch.hex file is the application file.

Intel .hex is a common output notation for binary files that also include location for the binary.

https://en.wikipedia.org/wiki/Intel_HEX

To program the boards

1. Copy the two .hex files to a file folder on your Windows PC.
2. Run the SmartRF Flash Programmer 2 program
3. Plug in your LaunchPad CC2650 Board into USB
4. Refresh the SmartRF list of Connected Devices until your CC2650 is recognized
5. Select the CC2650 in Connected Devices (in grey)
6. Indicate you want to program Multiple images on the Main Tab
7. Indicate you want to Erase, Program and Verify with CRC Check
8. Press the Play button to initiate programming the flash memory on the CC2650

The ZigBee device is programmed to auto-join and to auto-detect a light.


![SmartRFFlashProgrammer2](images/flashprogrammer2.jpg)

# Step 3 - Toggle the Light

Press BTN-1 (Near the large chip) to toggle the ZigBee Coordinator Light.

Wait for instruction, then press BTN-2 to enter EZ-Mode and toggle both ZigBee
Coordinator and ZigBee Router Light.

We may move the Router down the hallway to show true (out of range) multi-hop.

## Note for Remote Students

Since the CC2650 Doesn't support a ZigBee Coordinator, it may be tough to make a ZigBee
network! :-)

However, the part does support the MAC Full Function Device (Coordinator) and a
MAC Reduced Function Device (End-Device), so two LaunchPad CC2650 can be used for
an 802.15.4 Network.

See http://www.ti.com/product/CC2650/toolssoftware


[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartA.md) ZigBee Routing  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Beacons  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Profiles  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/homework.md) Install Wolf-SSL tools  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)


# Lab6 Part C - Bluetooth Beacons

* How to 
* How to display the beacon in your iPhone or Android

# Step 1 - Install the Physical Web App

Enable Bluetooth in your phone / tablet.

Get the app.

https://itunes.apple.com/us/app/physical-web/id927653608?mt=8&ign-mpt=uo%3D4

https://play.google.com/store/apps/details?id=physical_web.org.physicalweb&hl=en

There may be other ways to show the Beacons in your phone / tablet (Chrome is
supposed to have it built-in. I haven't found out how to enable.


# Step 2 - Cause your Rapsberry PI 3 to start emitting Eddystone-URL Beacons

Configure your RPi as a beaconing device.

Note: if you have trouble with unable to resolve hostname, try looking at the files

pi@iot40a2:~ $ nano /etc/hostname  
pi@iot40a2:~ $ sudo nano /etc/hostname  

```
$ ssh pi@<my_ip_addr>

# verify HCI is available
pi$ hciconfig -h

# Enable bluetooth
pi$ sudo hciconfig hci0 up

# Set the bluetooth device to advertise and not connectable
pi$ sudo hciconfig hci0 leadv 3

# Enter beacon data
pi$ sudo hcitool -i hci0 cmd 0x08 0x0008 15 02 01 06 03 03 aa fe 0d 16 aa fe 10 00 03 70 63 65 2e 75 77 02 00 00 00 00 00 00 00 00 00 00

```

15 02 01 06 03 03 aa fe 0d 16 aa fe 10 00 03 70 63 65 2e 75 77 02 00 00 00 00 00 00 00 00 00 00
sudo hcitool -i hci0 cmd 0x08 0x0008 1d 02 01 06 03 03 aa fe 15 16 aa fe 10 00 03 74 69 6e 79 75 72 6c 00 6d 71 6f 63 70 37 62 00 00



http://tinyurl.com/mqocp7b

For a description of the format of the beacons

https://github.com/google/eddystone/tree/master/eddystone-url


You've only got 32-bytes total for the BLE beacon.



# Step 3 - Make your own beacons

## Beacon Format

See format of beacon at:

https://github.com/google/eddystone/tree/master/eddystone-url

## TinyURL and goo.gl make short URLs

TinyURL allows you to create a short URL for a much longer one

https://tinyurl.com

https://tinyurl.com/lhzansa is the same as https://www.pce.uw.edu/certificates/internet-of-things

Google also does the same thing with URL shortener: https://goo.gl

## Use echo and Hexdump to get the ASCII codes for your URL

```
pi$ echo "pce.uw.edu" >x.txt
pi$ hexdump -C x.txt
```

## Eddystone Format in Detail

0x08  #OGF = Operation Group Field = Bluetooth Command Group = 0x08
0x0008  #OCF = Operation Command Field = HCI_LE_Set_Advertising_Data = 0x0008

15  Length. The hexadecimal 15 converts to 21 decimal which is the number of bytes that follow  
02  Length  
01  Flags data type value  
06  Flags data  
03  Length  
03  Complete list of 16-bit Service UUIDs data type value  
aa  16-bit Eddystone UUID  
fe  16-bit Eddystone UUID  
0d  Length. The hexadecimal 0f converts to 15 decimal which is the number of bytes that follow  
16  Service Data data type value  
aa  16-bit Eddystone UUID  
fe  16-bit Eddystone UUID  
10  Frame Type = URL  
00  TX Power (this should be calibrated)  
03  URL Scheme (http:// = 0x02)(https:// = 0x03).  
70  ‘p’ in hexadecimal  
63  ‘c’ in hexadecimal  
65  ‘e’ in hexadecimal  
2e  ‘.’ in hexadecimal  
75  ‘u’ in hexadecimal  
77  ‘w’ in hexadecimal  
08  .edu (.edu = 0x02)  
00  
00  
00  
00  
00  
00  
00  
00  
00  
00  

https://tinyurl.com/lhzansa


[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartA.md) ZigBee Routing  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Beacons  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Profiles  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/homework.md) Install Wolf-SSL tools  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab6 Part C - BlueTooth Low Energy (BLE) Project Zero

In this Lab, you'll learn

* About the Project 0 BLE Application
* How to program the LaunchPad CC2650 for BLE
* How to program your board from Cloud Tools
* How to use Code Composer Studio
* Resources for doing your own BLE experiments


# Resources

There are a couple resources I would suggest you should look into:
 
1. SimpleLink Academy (http://software-dl.ti.com/lprf/simplelink_academy/overview.html) – this is probably the best place for a beginner to start. If you are already familiar with TI-RTOS, I would suggest you start with the BLE Fundamentals lab. These labs use Project Zero which is a really good starter project for a peripheral role.
2. SimpleLink Github page (https://github.com/ti-simplelink/ble_examples) – here we host many examples outside of the SDK. The ble_examples-2.2 branch has the latest examples for the CC2650 including several beacon examples.
3. TI BLE Wiki (https://github.com/ti-simplelink/ble_examples) – this has a lot of useful information and resources. I would suggest looking at the beacon app notes and reference design.

# Step 1 - The Cloud Tools

https://dev.ti.com

CCS Cloud is Cloud Composer Studio in the cloud.



# Step 2 - Installing TI Bluetooth Software

If you haven't already, install the BLE stack for the CC2650. This will allow you to make local
applications with Code Composer Studio

http://www.ti.com/product/CC2650/toolssoftware

Get the BLE-STACK-2-1-1 (for CC2650)   http://www.ti.com/tool/ble-stack


# Step 3 - Installing Tools

## Putty

This tool will allow you to use the serial port for monitoring. It's also useful for SSH.

http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html

## Google Chrome

If you don't already have it installed, install Google Chrome. This is required by
the TI Cloud Tools.

[Google Chrome Download](https://www.google.com/chrome/browser/features.html?brand=CHBD&gclid=CPSFgZSC19MCFZIBaQodVtEHXA&dclid=CO_qm5SC19MCFY5ofgodprwOOw)


# Step 4 We'll Go Through This BLE Tutorial Together

Go to https://dev.ti.com

http://dev.ti.com/tirex/content/cc26xx_bluetooth_smart/cc26xx_bluetooth_smart__2.01.00.44423/Projects/ble/ProjectZero/project0_resources/prz/index.html

http://software-dl.ti.com/lprf/simplelink_academy/overview.html#videos


[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartA.md) ZigBee Routing  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Beacons  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/LabPartB.md) Bluetooth Profiles  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab6/homework.md) Install Wolf-SSL tools  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Homework for Week 7

Try turning the Raspberry Pi into an access point.
See Lab7/docs/setting-up-a-raspberry-pi-as-a-wifi-access-point.pdf

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Week 7 - IoT Security

## Lab Objectives

In this lab you'll learn:

* How to secure your IoT devices and transactions
* What are the different cryptographic algorithms and their uses
* How to set up the Rapsberry Pi as an Access Point with WPA2
* How TLS works and how to create self-signed certs for lab work
* How to create a secure web page

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartA.md) Cryptographics  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartB.md) TLS and self-signed certs  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartC.md) WPA2 and Access Points  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab/homework.md) Move Quizical to your own free Heroku account  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab7 Part A - Cryptographics 

In this section of the lab you will learn

* Hash functions and when to use them
* Encryption algorithms and when to use them
* Public-key algorithms and when to use them

We'll use the Rapsberry Pi for exploring cryptography.

## Step 1 - Install pycrypto

Install pycrypt on your Rapsberry Pi

Either: 

```
pi$ sudo apt-get install python-crypto
```

Or do: 

```
pi$ sudo apt-get install python2.7-dev
pi$ sudo pip install pycrypto
```

Verify installation worked

```
pi$ python
>>> from Crypto.Hash import SHA256
>>> hash = SHA256.new('Hello World').hexdigest()
>>> print 'hash len(' + str(len(hash) / 2) + ') ' + hash
```

## Step 2 - Hash Algorithms

This explores hashing by making a user/password file.

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab7/src
pi$ iotsha256.py
```

Try entering a few different users and passwords by pressing Enter (no name)
to create new users.

Try logging into each account by typing username and password.

Try logging in with the wrong password.

Let's examine the file passwords.txt.

Easy: guess the password for user 'hello'.

Bonus: See if you can determine the password for user "drew".

Hint: http://md5decrypt.net/en/Sha256/

## Step 3 - Block Cipher (AES)

This lab uses MQTT to send/receive encrypted text.

This uses a global built-in key.

```
pi$ python mqtt_subscribe_aes.py
```

In another SSH terminal window on your Raspberry PI, run the MQTT
publish application. This requires you to enter a key

```
pi$ python mqtt_publish_aes.py secretkey
```

Publish some lines of text. Notice the text is encoded on sending,
and decoded on receiving at the Subscriber.

Try changing your key on the subscriber (by editing the mqtt_subscribe_aes.py).

Make sure to change the key on the cmdline for the publisher.

Note: the AES key must either by 16 bytes (AES-128) or 32 bytes (AES-256)


## Step 4 - Public Key (RSA)

```
pi$ python iotpki.py The quick brown fox jumped over the lazy dog.
```

## Step 5 - Signing a Public Key

Sign

Signing a message can be useful to check the author of a message and make
sure we can trust its origin. Next is an example on how to sign a message.
The hash for this message is calculated first and then passed to the
sign() method of the RSA key.

Start by running python from SSH on the Rapsberry Pi.

**Signing** 

```
$pi python
>>> from Crypto.Hash import SHA256
>>> from Crypto.PublicKey import RSA
>>> from Crypto import Random
>>> random_generator = Random.new().read
>>> key = RSA.generate(1024, random_generator)
>>> text = 'my_signature'
>>> hash = SHA256.new(text).digest()
>>> signature = key.sign(hash, '')
>>> public_key = key.publickey()
```

**Verify**

Knowing the public key, it is easy to verify a message. The plain text is sent
to the user along with the signature. The receiving side calculates the hash
value and then uses the public key verify() method to validate its origin.

```
>>> text = 'my_signature'
>>> hash = SHA256.new(text).digest()
>>> public_key.verify(hash, signature)
True

>>> text = 'not_my_signature'
>>> hash = SHA256.new(text).digest()
>>> public_key.verify(hash, signature)
False
```

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartA.md) Cryptographics  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartB.md) TLS and self-signed certs  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartC.md) WPA2 and Access Points  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab/homework.md) Move Quizical to your own free Heroku account  


[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab7 Part B - Making an encrypted website using self-certs

In this lab, you'll learn about Nginx

Steps:

1) Update the system

`pi$ sudo apt update`

2) Install Nginx Web Server

```
pi$ sudo apt install nginx
pi$ sudo service nginx start
```

3) Verify Nginx is working http://<YOUR_IP>
   Verify that Nginx SSL is NOT working https://<YOUR_IP>

4) Generate OpenSSL Certificate

```bash
$ ./generate_key.sh
Generating a 2048 bit RSA private key
.........................................................................+++
.......+++
writing new private key to '{hostname}.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:Washington
Locality Name (eg, city) []:Bellevue
Organization Name (eg, company) [Internet Widgits Pty Ltd]:IOT 110
Organizational Unit Name (eg, section) []:IOT 110 (B) Spring
Common Name (e.g. server FQDN or YOUR name) []:Josh Welschmeyer
Email Address []:joshwelschmeyer@gmail.com
```

5) Create the folders to store generated keys

`$ sudo mkdir -p /etc/ssl/certs/iot /etc/ssl/certs/iot/private`

6) Copy the keys to the created folders

```bash
$ sudo cp {hostname}.crt /etc/ssl/certs/iot
$ sudo cp {hostname}.key /etc/ssl/certs/iot/private
```

7) Stop Nginx

```
pi$ sudo service nginx stop
```

8) Update the Nginx Configuration

Remove the currently enabled site configuration

```
pi$ sudo rm /etc/nginx/sites-enabled/default
```

Copy the new site configuration

Edit the iot-nginx.conf for your local hostname.

```
pi$ nano iot-nginx.conf
pi$ sudo cp iot-nginx.conf /etc/nginx/sites-enabled
```

9) Start your Flash application as a background process

```
pi$ pwd
/home/pi/Documents/Git/iot-210B-student/Lab7/src
pi$ python apserver.py &
```

10) Start Nginx

```
pi$ sudo service nginx start
pi$ hostname -I
  172.22.194.141
```

11) On your desktop, curl to your IP address (returned by hostname)

```
curl 172.22.194.141/api/v1?hello=world
```


[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartA.md) Cryptographics  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartB.md) TLS and self-signed certs  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartC.md) WPA2 and Access Points  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab/homework.md) Move Quizical to your own free Heroku account  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)


# Lab7 Part C - Making your Rapsberry PI an Access Point

We're going to follow the Ada Fruit Tutorial.

See gitlab.com/Gislason/iot-210B-student/Lab3


[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartA.md) Cryptographics  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartB.md) TLS and self-signed certs  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab7/LabPartC.md) WPA2 and Access Points  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab/homework.md) Move Quizical to your own free Heroku account  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Homework for Lab8

Obtain an Echo Dot if you want to do the Alexa Programming from home
with your own Echo Dot.

I'll try to provide an MQTT bases solution for remote students who
don't want to own an Echo Dot.

Obtain an AWS IoT Button. I plan to provide a means of programming
the button to work with ASK.

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Week 8 - APIs, including DropBox, PhilipsHue, IFTTT

## Lab Objectives

In this lab you'll learn:

* How to connect to and use various IoT APIs
* Concepts around connecting IoT Devices to the Cloud

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartA.md) DropBox API  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartB.md) Philips Hue API  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartC.md) IFTTT API  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab/homework.md) None  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab8 Part A - Dropbox API

In this section of the lab you will learn:

* How add the Dropbox API to a python program
* How to "salt" passwords so they can't be easily hacked

We'll use the Rapsberry Pi for exploring cryptography.

## Step 1 - Setup a Dropbox Account

Create a Dropbox account and login

1. On your desktop PC, go to https://www.dropbox.com/developers/apps/create
and choose "Dropbox API App" (not the Business API)
2. Choose "App Folder - Access to a single folder created specifically for your app."
3. Name the app "iot210", and Create the app.
4. On the iot210 app Settings tab, choose Generate Access Token.
5. You'll need this token (a long string of random ASCII characters), so leave page open

## Step 2 - Install dropbox on your Raspberry Pi

Install dropbox on your Rapsberry Pi

```
ssh pi@{my.pi.ip.addr}
pi$ sudo pip install dropbox
```

Verify installation worked

```
pi$ python
>>> import dropbox
```

## Step 3 - Python Program To Try Out Dropbox API

This step uses the same login program we used last week, but modified
to use dropbox (now called dropbox_sha256.py in Lab8) for file storage.

You'll need to add the token from step 1 into the program for it to work.


```
pi$ cd ~/Documents/Git/iot-210B-student
pi$ git pull
pi$ cd Lab8/src
pi$ nano dropbox_sha256.py
  add your dropbox token, WriteOut(^O), then Exit(^X)
```

Then, run the program. It should behave like it did last week (able
to create new users and login as existing users).

On your PC web browser, Go to: https://www.dropbox.com/home/Apps/iot210.
Notice there is no "filename.txt".

Now run the program.

```
pi$ dropbox_sha256.py
```

Notice the file "passwords.txt" has been created in the Application Folder
at https://www.dropbox.com/home/Apps/iot210.

Try entering a few different users and passwords by pressing Enter (no name)
to create new users.

Try logging into each account by typing username and password.

Try logging in with the wrong password.

Let's examine the file passwords.txt on DropBox.


## Step 3 - Password Challenge

Challenge: An existing user of "drew" is in the file unbreakable(??)
`passwords.txt`.

See http://md5decrypt.net/en/Sha256/

Thanks to 


[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartA.md) DropBox API  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartB.md) Philips Hue API  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartC.md) IFTTT API  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab/homework.md) None  


[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab8 Part B - Philips Hue API

In this section of the lab you will learn:

* How add the Philips Hue API to a python program
* How to toggle a light base on Hue API

## Step 1 - Install Philips Hue API

Install Philips Hue API on your Raspberry PI

```
pi$easy_install phue
```
or

```
$ sudo pip install phue
```

See also https://github.com/studioimaginaire/phue for more installation instructions.

## Step 2 - Determine address of Philips Hue Gatewaay

In your browser, go to: https://www.meethue.com/api/nupnp

This should tell you the IP address of the Philips Hue Bridge.

Enter this IP address into hue_color.py (see line 8, BRIDGE_IP)

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab8/src
pi$ nano hue_color.py
  BRIDGE_IP   = '10.0.1.6'
```

## Step 3 - Try Out the hue_color.py program

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab8/src
pi$ python 
```

## Step 4 - Explore Philips Developer's Portal

Register (it will send you an email), then use the emailed link to log in.

https://developers.meethue.com/user/login
https://developers.meethue.com/documentation/getting-started
https://developers.meethue.com/documentation/lights-api

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartA.md) DropBox API  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartB.md) Philips Hue API  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartC.md) IFTTT API  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab/homework.md) None  


[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab8 Part C - ifthisthenthat (IFTTT)

In this section of the lab you will learn:

* What IFTTT is
* How to use IFTTT
* How to develop for IFTTT
* How to integrate IFTTT into your Python programs

## Step 1 - Sign Up for IFTTT

https://ifttt.com

## Step 2 - Create an action using the IFTTT Website

On your PC, sign up for twitter if you don't already have an account at

https://twitter.com

Then go to IFTTT to Create New Applet (click on your username, new Applet).

https://ifttt.com

This should bring you to a page of if[this]thenthat.

Click on "This" to connect to a trigger. Connect to twitter (making a tweet
on a particular hashtag. I used `#iot210`.

You'll need to allow IFTTT access to your twitter account.

Then click on "That" to connect the action. In this case, send an SMS.
It will ask for your phone #, and will text a code to your phone.

Enter the code.

Now IFTTT will connect the trigger (tweeting) to the action (texting).

Unfortunately, IFTTT doesn't do this immediately. It says it will
happend within the hour.


## Step 3 - IFTTT in a Python Program

Go to https://ifttt.com/maker_webhooks

Click on the documentation button. This will generate a unique key
for you. You can test it by doing the following:

```
curl -X POST https://maker.ifttt.com/trigger/ping/with/key/{mykey}

curl -X POST https://maker.ifttt.com/trigger/{event}/with/key/{mykey}
curl -X POST -H "Content-Type: application/json" -d '{"value1":"1","value2":"2","value3":"2"}' https://maker.ifttt.com/trigger/{event}/with/key/{mykey}
```

On your raspberry Pi, you must add the key to the program `ifttt_ping.py`.

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab8/src
pi$ nano ifttt_ping.py
pi$ python ifttt_ping.py
```

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartA.md) DropBox API  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartB.md) Philips Hue API  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab8/LabPartC.md) IFTTT API  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab/homework.md) None  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Homework for Lab9 - Capstone Projects

The Capstone project should be completed before, during the final class or shortly
thereafter.

Feel free to work in teams, or to create individual projects.

Use technology you learned during class (HTTP, JSON, RESTful APIs, Cloud Hosting like Heroku,
Cryptography, MQTT, Philips Hue API, IFTTT, DropBox, AWS, etc...) to create something
interesting to you.

Check in the source code to your own GitLab account, and send me a link via Canvas InBox Email.

https://canvas.uw.edu/conversations#filter=type=inbox

## Some Capstone Ideas

(Feel free to use your own ideas)

* Create something with IFTTT that involves your Raspberry Pi
* With the LaunchPad CC2560, create a Philips Hue Switch (use API)
* Create a LaunchPad C2650 MAC Network that toggles other CC2650 lights
* Use Bluetooth Beacons to make a “person is present” application (e.g. auto door unlock, or find my kid)
* Create an MQTT publish/subscribe private Internet of Things
* Using Heroku (for hosted app) and Dropbox (for hosted data), create an IoT hub
* Turn your Raspberry Pi into a IoT hub for controlling things
* Create a Restful API on the Web that allows someone
* Create an AWS Lamba Skill and win a Limited edition Alexa Dev Shirt https://developer.amazon.com/alexa-skills-kit/alexa-developer-skill-promotion

Any idea is acceptible as long as it demonstrates something to do with the internet of things.

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Week 9 - Amazon Web Services (AWS) IoT and Alexa APIs

## Lab Objectives

In this lab you'll learn:

* How to create an AWS account
* How to install Python tools for AWS on your Rapsberry Pi
* How to connect to AWS IoT APIs using your Raspberry Pi

## Lab Links

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartA.md) AWS Security and S3  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartB.md) AWS Dash Button  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartC.md) AWS and Alexa  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/homework.md) Capstone Projects  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab 9 Part A - Amazon Web Services AWS IoT, Security and S3

In this section of the lab you will learn:

* How to create an AWS account
* How to install Python tools for AWS on your Rapsberry Pi
* How to connect to AWS IoT APIs using your Raspberry Pi
* Allow a "thing" to publish/subscribe using AWS MQTT

We'll use the Rapsberry Pi for exploring cryptography.

## Step 1 - Create an Amazon AWS Account

Go to https://aws.amazon.com/free/
Go to [Amazon AWS](https://aws.amazon.com) and sign up.

This page has a good overview of all the AWS products. We'll be concentrating
on IoT products (IoT Platform and Button).


## Step 2 - Install the AWS Command-Line Tools

First, install the AWS command-line tools on your Raspberry Pi. Also install
boto3 and AWSIoTPythonSDK at this time.

```
pi$ sudo easy_install awscli
pi$ sudo easy_install boto3
pi$ sudo easy_install AWSIoTPythonSDK
```

Verify AWS command-line tools installed.

```
pi$ aws --version
```

Next, create the ~/.aws/ folder and copy the config file (that says we'll be
using `us-west-2` region). AWS segments things in regions.

```
pi$ cd ~/Documents/Git/iot-210B-student/Lab9/src
pi$ mkdir ~/.aws/
pi$ cp config ~/.aws/
```

## Step 2.A Create and Copy Credentials

* Login to Console at https://aws.amazon.com
* Go to IAM (Identity and Access Manager)
* Create Group with all Full IoT Access called iot210
* Create User with group you just created iot210 for programmatic access
* You will need the access_id and secret_key


```
pi$ aws configure
aws configure
          AWS Access Key ID [None]: accesskey
          AWS Secret Access Key [None]: secretkey
          Default region name [None]: us-west-2
          Default output format [None]:
```

Use us-west-2 for your region


## Step 3 - Create a Thing

```
pi$ aws iot create-thing --thing-name "thingName"
pi$ aws iot list-things
```

## Step 4 - Create the Public/Private Keys and Certificate

On your desktop browser, go to the AWS Primary Root Certificate Authority
https://www.symantec.com/content/en/us/enterprise/verisign/roots/VeriSign-Class%203-Public-Primary-Certification-Authority-G5.pem

This file has already been saved for you as `awsIotRootCert` since it is the same for all users of AWS.


```
pi$ cd ~/Documents/Git/iot-210B-student/Lab9/src
pi$ aws iot create-keys-and-certificate --set-as-active --certificate-pem-outfile cert.pem --public-key-outfile publicKey.pem --private-key-outfile privkey.pem
```

This will show the keys and certificate and an "arn". Amazon Resource Name.

```
pi$ aws iot list-certificates
```

Now, create the policy that allows this "thing" to access all AWS IOT services.

```
pi$ aws iot create-policy --policy-name "PubSubToAnyTopic" --policy-document file://iotpolicy.json
```
Now, attach the policy and the thing to the arn.

```
pi$ aws iot attach-principal-policy --principal "certificate-arn" --policy-name "PubSubToAnyTopic"
pi$ aws iot attach-thing-principal --thing-name "thingName" --principal "certificate-arn"
```

Now you should be ready to.

## Step 5 - Modify the Pub/Sub applications for your "thing"

Update the awsiotput.py and the awsiotsub.py to have your `clientId` and `thingName`

```
pi$ nano awsiotpub.py
pi$ nano awsiotsub.py
pi$ python awsiotsub.py
```

In a separate SSH window, run the publisher

```
pi# python awsiotpub.py
```

## Step 6 - Experiment with Device Shadow on your "thing"

http://docs.aws.amazon.com/iot/latest/developerguide/thing-shadow-mqtt.html

topic: $aws/things/{myThing}/shadow/update
payload: { "state" : { "desired" : { "color" : "red", "power" : "on" }}}

[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartA.md) AWS Security and S3  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartB.md) AWS AWS IoT Button  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartC.md) AWS and Alexa  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/homework.md) Capstone Projects  



[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab 9 Part B - AWS and the AWS IoT Button

In this section of the lab you will learn:

* How to use the AWS IoT Button to control
* How to create an AWS Lambda Function

This lab assumes you have already purchased an AWS IoT Dash Button

## Step 1 - Purchase a AWS IoT Button

https://aws.amazon.com/iotbutton/getting-started/

## Step 2 - Connect AWS IoT Button To your Network

Download the AWS IoT Button App from your app store. I tried the iOS version at:

https://itunes.apple.com/us/app/aws-iot-button/id1178216626?mt=8

## Step 3 - Activiating the AWS IoT Button

Follow the instructions in the app to Add the button to your AWS account


[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartA.md) AWS Security and S3  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartB.md) AWS AWS IoT Button  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartC.md) AWS and Alexa  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/homework.md) Capstone Projects  



[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)

# Lab 9 Part C - AWS and Alexa Skill Kit (ASK)

In this section of the lab you will learn:

* How to add a spoken Skill to an Echo Dot (or Alexa equivalent)
* Learn a little about the Alexa Skills Kit

## Step 1 - Sign Up for Developer Account

Go to `developer.amazon.com` and sign up.

Answer no to monitizing, so you don't have to set up any payment information.

## Step 2 - Introduction to Amazon Skills Kit

Even if you don't have an Echo Dot, you can follow along with the example.

On your desktop browser, go to:

https://developer.amazon.com/alexa-skills-kit/tutorials/fact-skill-1

We'll go through this tutorial together in class.

For step 5, I created a skill called i.o.t.two.ten in english



[PART A](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartA.md) AWS Security and S3  
[PART B](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartB.md) AWS AWS IoT Button  
[PART C](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/LabPartC.md) AWS and Alexa  
[Homework](https://gitlab.com/Gislason/iot-210B-student/tree/master/Lab9/homework.md) Capstone Projects  

[IOT STUDENT HOME](https://gitlab.com/Gislason/iot-210B-student/blob/master/README.md)
